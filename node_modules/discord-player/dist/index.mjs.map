{"version":3,"sources":["../src/index.ts","../src/utils/PlayerEventsEmitter.ts","../src/utils/Util.ts","../src/utils/AudioFilters.ts","../src/extractors/BaseExtractor.ts","../src/extractors/ExtractorExecutionContext.ts","../src/Structures/GuildNodeManager.ts","../src/Structures/GuildQueue.ts","../src/Structures/Playlist.ts","../src/Structures/GuildQueueHistory.ts","../src/Structures/GuildQueuePlayerNode.ts","../src/utils/QueryResolver.ts","../src/types/types.ts","../src/Structures/Track.ts","../src/Structures/GuildQueueAudioFilters.ts","../src/utils/FFmpegStream.ts","../src/Structures/GuildQueueStatistics.ts","../src/utils/TypeUtil.ts","../src/utils/__internal__/_container.ts","../src/utils/__internal__/addPlayer.ts","../src/utils/__internal__/clearPlayer.ts","../src/utils/__internal__/getPlayers.ts","../src/utils/__internal__/getGlobalRegistry.ts","../src/Structures/VoiceReceiverNode.ts","../src/Structures/SearchResult.ts","../src/Structures/PlayerError.ts","../src/VoiceInterface/VoiceUtils.ts","../src/VoiceInterface/StreamDispatcher.ts","../src/utils/QueryCache.ts","../src/Player.ts","../src/hooks/common.ts","../src/hooks/useHistory.ts","../src/hooks/usePlayer.ts","../src/hooks/useQueue.ts","../src/hooks/useMasterPlayer.ts","../src/hooks/useMetadata.ts","../src/hooks/useTimestamp.ts","../src/hooks/stream/onAfterCreateStream.ts","../src/hooks/stream/onBeforeCreateStream.ts"],"sourcesContent":["import { version as djsVersion } from 'discord.js';\nexport * from './utils/PlayerEventsEmitter';\nexport * from './utils/AudioFilters';\nexport * from './extractors/BaseExtractor';\nexport * from './extractors/ExtractorExecutionContext';\nexport * from './Structures';\nexport * from './VoiceInterface/VoiceUtils';\nexport * from './VoiceInterface/StreamDispatcher';\nexport * from './utils/Util';\nexport * from './utils/TypeUtil';\nexport * from './types/types';\nexport * from './utils/FFmpegStream';\nexport * from './utils/QueryCache';\nexport * from './utils/QueryResolver';\nexport * from './Player';\nexport * from './hooks';\nexport {\n    AudioFilters as PCMAudioFilters,\n    type BiquadFilters,\n    FilterType as BiquadFilterType,\n    type PCMFilters,\n    Q_BUTTERWORTH,\n    VolumeTransformer,\n    BASS_EQ_BANDS,\n    AF_NIGHTCORE_RATE,\n    AF_VAPORWAVE_RATE,\n    FiltersChain\n} from '@discord-player/equalizer';\n\n// eslint-disable-next-line @typescript-eslint/no-inferrable-types\nexport const version: string = '6.1.1';\n\nif (!djsVersion.startsWith('14')) {\n    process.emitWarning(`Discord.js v${djsVersion} is incompatible with Discord Player v${version}! Please use >=v14.x of Discord.js`);\n}\n","import { DefaultListener } from '@discord-player/utils';\nimport { ListenerSignature } from '@discord-player/utils';\nimport { EventEmitter } from '@discord-player/utils';\nimport { Util } from './Util';\n\nexport class PlayerEventsEmitter<L extends ListenerSignature<L> = DefaultListener> extends EventEmitter<L> {\n    public constructor(public requiredEvents: Array<keyof L> = []) {\n        super();\n    }\n\n    public emit<K extends keyof L>(name: K, ...args: Parameters<L[K]>) {\n        if (this.requiredEvents.includes(name) && !this.eventNames().includes(name)) {\n            // eslint-disable-next-line no-console\n            console.error(...args);\n            Util.warn(\n                `No event listener found for event \"${String(name)}\". Events ${this.requiredEvents.map((m) => `\"${String(m)}\"`).join(', ')} must have event listeners.`,\n                'UnhandledEventsWarning'\n            );\n            return false;\n        }\n\n        return super.emit(name, ...args);\n    }\n}\n","import { StageChannel, VoiceChannel } from 'discord.js';\nimport { TimeData } from '../types/types';\nimport { setTimeout } from 'timers/promises';\n\nclass Util {\n    /**\n     * Utils\n     */\n    private constructor() {} // eslint-disable-line @typescript-eslint/no-empty-function\n\n    /**\n     * Creates duration string\n     * @param {object} durObj The duration object\n     * @returns {string}\n     */\n    static durationString(durObj: Record<string, number>) {\n        return Object.values(durObj)\n            .map((m) => (isNaN(m) ? 0 : m))\n            .join(':');\n    }\n\n    /**\n     * Parses milliseconds to consumable time object\n     * @param {number} milliseconds The time in ms\n     * @returns {TimeData}\n     */\n    static parseMS(milliseconds: number) {\n        if (isNaN(milliseconds)) milliseconds = 0;\n        const round = milliseconds > 0 ? Math.floor : Math.ceil;\n\n        return {\n            days: round(milliseconds / 86400000),\n            hours: round(milliseconds / 3600000) % 24,\n            minutes: round(milliseconds / 60000) % 60,\n            seconds: round(milliseconds / 1000) % 60\n        } as TimeData;\n    }\n\n    /**\n     * Builds time code\n     * @param {TimeData} duration The duration object\n     * @returns {string}\n     */\n    static buildTimeCode(duration: TimeData) {\n        const items = Object.keys(duration);\n        const required = ['days', 'hours', 'minutes', 'seconds'];\n\n        const parsed = items.filter((x) => required.includes(x)).map((m) => duration[m as keyof TimeData]);\n        const final = parsed\n            .slice(parsed.findIndex((x) => x !== 0))\n            .map((x) => x.toString().padStart(2, '0'))\n            .join(':');\n\n        return final.length <= 3 ? `0:${final.padStart(2, '0') || 0}` : final;\n    }\n\n    /**\n     * Picks last item of the given array\n     * @param {any[]} arr The array\n     * @returns {any}\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static last<T = any>(arr: T[]): T {\n        if (!Array.isArray(arr)) return arr;\n        return arr[arr.length - 1];\n    }\n\n    /**\n     * Checks if the voice channel is empty\n     * @param {VoiceChannel|StageChannel} channel The voice channel\n     * @returns {boolean}\n     */\n    static isVoiceEmpty(channel: VoiceChannel | StageChannel) {\n        return channel && channel.members.filter((member) => !member.user.bot).size === 0;\n    }\n\n    /**\n     * Safer require\n     * @param {string} id Node require id\n     * @returns {any}\n     */\n    static require(id: string) {\n        try {\n            return { module: require(id), error: null };\n        } catch (error) {\n            return { module: null, error };\n        }\n    }\n\n    static async import(id: string) {\n        try {\n            const mod = await import(id);\n            return { module: mod, error: null };\n        } catch (error) {\n            return { module: null, error };\n        }\n    }\n\n    /**\n     * Asynchronous timeout\n     * @param {number} time The time in ms to wait\n     * @returns {Promise<unknown>}\n     */\n    static wait(time: number) {\n        return setTimeout(time, undefined, { ref: false });\n    }\n\n    static noop() {} // eslint-disable-line @typescript-eslint/no-empty-function\n\n    static async getFetch() {\n        if ('fetch' in globalThis) return globalThis.fetch;\n        for (const lib of ['node-fetch', 'undici']) {\n            try {\n                return await import(lib).then((res) => res.fetch || res.default?.fetch || res.default);\n            } catch {\n                try {\n                    // eslint-disable-next-line\n                    const res = require(lib);\n                    if (res) return res.fetch || res.default?.fetch || res.default;\n                } catch {\n                    // no?\n                }\n            }\n        }\n    }\n\n    static warn(message: string, code = 'DeprecationWarning', detail?: string) {\n        process.emitWarning(message, {\n            code,\n            detail\n        });\n    }\n\n    static randomChoice<T>(src: T[]): T {\n        return src[Math.floor(Math.random() * src.length)];\n    }\n}\n\nexport { Util };\n","import { FiltersName } from '../types/types';\n\nconst bass = (g: number) => `bass=g=${g}:f=110:w=0.3`;\n\nclass AudioFilters {\n    public constructor() {\n        return AudioFilters;\n    }\n\n    public static filters: Record<FiltersName, string> = {\n        bassboost_low: bass(15),\n        bassboost: bass(20),\n        bassboost_high: bass(30),\n        '8D': 'apulsator=hz=0.09',\n        vaporwave: 'aresample=48000,asetrate=48000*0.8',\n        nightcore: 'aresample=48000,asetrate=48000*1.25',\n        lofi: 'aresample=48000,asetrate=48000*0.9,extrastereo=m=2.5:c=disabled',\n        phaser: 'aphaser=in_gain=0.4',\n        tremolo: 'tremolo',\n        vibrato: 'vibrato=f=6.5',\n        reverse: 'areverse',\n        treble: 'treble=g=5',\n        normalizer2: 'dynaudnorm=g=101',\n        normalizer: 'acompressor',\n        surrounding: 'surround',\n        pulsator: 'apulsator=hz=1',\n        subboost: 'asubboost',\n        karaoke: 'stereotools=mlev=0.03',\n        flanger: 'flanger',\n        gate: 'agate',\n        haas: 'haas',\n        mcompand: 'mcompand',\n        mono: 'pan=mono|c0=.5*c0+.5*c1',\n        mstlr: 'stereotools=mode=ms>lr',\n        mstrr: 'stereotools=mode=ms>rr',\n        compressor: 'compand=points=-80/-105|-62/-80|-15.4/-15.4|0/-12|20/-7.6',\n        expander: 'compand=attacks=0:points=-80/-169|-54/-80|-49.5/-64.6|-41.1/-41.1|-25.8/-15|-10.8/-4.5|0/0|20/8.3',\n        softlimiter: 'compand=attacks=0:points=-80/-80|-12.4/-12.4|-6/-8|0/-6.8|20/-2.8',\n        chorus: 'chorus=0.7:0.9:55:0.4:0.25:2',\n        chorus2d: 'chorus=0.6:0.9:50|60:0.4|0.32:0.25|0.4:2|1.3',\n        chorus3d: 'chorus=0.5:0.9:50|60|40:0.4|0.32|0.3:0.25|0.4|0.3:2|2.3|1.3',\n        fadein: 'afade=t=in:ss=0:d=10',\n        dim: `afftfilt=\"'real=re * (1-clip((b/nb)*b,0,1))':imag='im * (1-clip((b/nb)*b,0,1))'\"`,\n        earrape: 'channelsplit,sidechaingate=level_in=64'\n    };\n\n    public static get<K extends FiltersName>(name: K) {\n        return this.filters[name];\n    }\n\n    public static has<K extends FiltersName>(name: K) {\n        return name in this.filters;\n    }\n\n    public static *[Symbol.iterator](): IterableIterator<{ name: FiltersName; value: string }> {\n        for (const [k, v] of Object.entries(this.filters)) {\n            yield { name: k as FiltersName, value: v as string };\n        }\n    }\n\n    public static get names() {\n        return Object.keys(this.filters) as FiltersName[];\n    }\n\n    // @ts-expect-error AudioFilters.length\n    public static get length() {\n        return this.names.length;\n    }\n\n    public static toString() {\n        return this.names.map((m) => (this as any)[m]).join(','); // eslint-disable-line @typescript-eslint/no-explicit-any\n    }\n\n    /**\n     * Create ffmpeg args from the specified filters name\n     * @param filter The filter name\n     * @returns\n     */\n    public static create<K extends FiltersName>(filters?: K[]) {\n        if (!filters || !Array.isArray(filters)) return this.toString();\n        return filters\n            .filter((predicate) => typeof predicate === 'string')\n            .map((m) => this.get(m))\n            .join(',');\n    }\n\n    /**\n     * Defines audio filter\n     * @param filterName The name of the filter\n     * @param value The ffmpeg args\n     */\n    public static define(filterName: string, value: string) {\n        this.filters[filterName as FiltersName] = value;\n    }\n\n    /**\n     * Defines multiple audio filters\n     * @param filtersArray Array of filters containing the filter name and ffmpeg args\n     */\n    public static defineBulk(filtersArray: { name: string; value: string }[]) {\n        filtersArray.forEach((arr) => this.define(arr.name, arr.value));\n    }\n}\n\nexport default AudioFilters;\nexport { AudioFilters };\n","import { User } from 'discord.js';\nimport { Readable } from 'stream';\nimport { Playlist } from '../Structures/Playlist';\nimport { Track } from '../Structures/Track';\nimport { PlayerEvents, SearchQueryType } from '../types/types';\nimport { ExtractorExecutionContext } from './ExtractorExecutionContext';\nimport type { RequestOptions } from 'http';\n\nexport class BaseExtractor {\n    /**\n     * Identifier for this extractor\n     */\n    public static identifier = 'com.discord-player.extractor';\n\n    /**\n     * Extractor constructor\n     * @param context Context that instantiated this extractor\n     * @param options Initialization options for this extractor\n     */\n    public constructor(public context: ExtractorExecutionContext, public options: Record<string, unknown> = {}) {}\n\n    /**\n     * Identifier of this extractor\n     */\n    public get identifier() {\n        return (this.constructor as typeof BaseExtractor).identifier;\n    }\n\n    /**\n     * This method will be executed when this extractor is activated\n     */\n    public async activate() {\n        // executed when this extractor is activated\n        return;\n    }\n\n    /**\n     * This method will be executed when this extractor is deactivated\n     */\n    public async deactivate() {\n        // executed when this extractor is deactivated\n        return;\n    }\n\n    /**\n     * Validate incoming query\n     * @param query The query to validate\n     */\n    public async validate(query: string, type?: SearchQueryType | null): Promise<boolean> {\n        void type;\n        return false;\n    }\n\n    /**\n     * Stream the given track\n     * @param info The track to stream\n     */\n    public async stream(info: Track): Promise<Readable | string> {\n        void info;\n        throw new Error('Not Implemented');\n    }\n\n    /**\n     * Handle the given query\n     * @param query The query to handle\n     */\n    public async handle(query: string, context: ExtractorSearchContext): Promise<ExtractorInfo> {\n        void context;\n        throw new Error('Not Implemented');\n    }\n\n    /**\n     * Get related tracks for the given track\n     * @param track The track source\n     */\n    public async getRelatedTracks(track: Track): Promise<ExtractorInfo> {\n        void track;\n        throw new Error('Not implemented');\n    }\n\n    /**\n     * A stream middleware to handle streams before passing it to the player\n     * @param stream The incoming stream\n     * @param next The next function\n     */\n    public handlePostStream(stream: Readable, next: NextFunction) {\n        return next(null, stream);\n    }\n\n    /**\n     * Dispatch an event to the player\n     * @param event The event to dispatch\n     * @param args The data to dispatch\n     */\n    public emit<K extends keyof PlayerEvents>(event: K, ...args: Parameters<PlayerEvents[K]>) {\n        return this.context.player.emit(event, ...args);\n    }\n\n    /**\n     * Create extractor response\n     * @param playlist The playlist\n     * @param tracks The track array\n     */\n    public createResponse(playlist?: Playlist | null, tracks: Track[] = playlist?.tracks || []): ExtractorInfo {\n        return { playlist: playlist || null, tracks };\n    }\n\n    /**\n     * Write debug message\n     * @param message The debug message\n     */\n    public debug(message: string) {\n        return this.context.player.debug(message);\n    }\n}\n\nexport type NextFunction = (error?: Error | null, stream?: Readable) => void;\n\nexport interface ExtractorInfo {\n    playlist: Playlist | null;\n    tracks: Track[];\n}\n\nexport interface ExtractorSearchContext {\n    type?: SearchQueryType | null;\n    requestedBy?: User | null;\n    requestOptions?: RequestOptions;\n}\n","import { Player } from '../Player';\nimport { Collection } from '@discord-player/utils';\nimport { BaseExtractor } from './BaseExtractor';\nimport { Util } from '../utils/Util';\nimport { PlayerEventsEmitter } from '../utils/PlayerEventsEmitter';\n\n// prettier-ignore\nconst knownExtractorKeys = [\n    'SpotifyExtractor',\n    'AppleMusicExtractor',\n    'SoundCloudExtractor',\n    'YouTubeExtractor',\n    'VimeoExtractor',\n    'ReverbnationExtractor',\n    'AttachmentExtractor'\n];\nconst knownExtractorLib = '@discord-player/extractor';\n\nexport interface ExtractorExecutionEvents {\n    /**\n     * Emitted when a extractor is registered\n     * @param context The context where extractor was registered\n     * @param extractor The extractor that was registered\n     */\n    registered: (context: ExtractorExecutionContext, extractor: BaseExtractor) => unknown;\n    /**\n     * Emitted when a extractor is unregistered\n     * @param context The context where extractor was unregistered\n     * @param extractor The extractor that was unregistered\n     */\n    unregistered: (context: ExtractorExecutionContext, extractor: BaseExtractor) => unknown;\n    /**\n     * Emitted when a extractor is activated\n     * @param context The context where this event occurred\n     * @param extractor The extractor which was activated\n     */\n    activate: (context: ExtractorExecutionContext, extractor: BaseExtractor) => unknown;\n    /**\n     * Emitted when a extractor is deactivated\n     * @param context The context where this event occurred\n     * @param extractor The extractor which was deactivated\n     */\n    deactivate: (context: ExtractorExecutionContext, extractor: BaseExtractor) => unknown;\n    /**\n     * Emitted when a extractor fails to activate/deactivate\n     * @param context The context where this event occurred\n     * @param extractor The extractor which was deactivated\n     */\n    error: (context: ExtractorExecutionContext, extractor: BaseExtractor, error: Error) => unknown;\n}\n\nexport class ExtractorExecutionContext extends PlayerEventsEmitter<ExtractorExecutionEvents> {\n    public store = new Collection<string, BaseExtractor>();\n    public constructor(public player: Player) {\n        super(['error']);\n    }\n\n    /**\n     * Load default extractors from `@discord-player/extractor`\n     */\n    public async loadDefault() {\n        const mod = await Util.import(knownExtractorLib);\n        if (mod.error) return { success: false, error: mod.error as Error };\n\n        knownExtractorKeys.forEach((key) => {\n            if (!mod.module[key]) return;\n            this.register(mod.module[key]);\n        });\n\n        return { success: true, error: null };\n    }\n\n    /**\n     * Validate if the given extractor is registered\n     * @param identifier The extractor identifier\n     */\n    public isRegistered(identifier: string) {\n        return this.store.has(identifier);\n    }\n\n    /**\n     * The size of registered extractors\n     */\n    public get size() {\n        return this.store.size;\n    }\n\n    /**\n     * Get single extractor\n     * @param identifier The extractor to get\n     */\n    public get(identifier: string) {\n        return this.store.get(identifier);\n    }\n\n    /**\n     * Register single extractor\n     * @param _extractor The extractor to register\n     * @param options Options supplied to the extractor\n     */\n    public async register(_extractor: typeof BaseExtractor, options: Record<string, unknown> = {}) {\n        if (typeof _extractor.identifier !== 'string' || this.store.has(_extractor.identifier)) return;\n        const extractor = new _extractor(this, options);\n\n        try {\n            this.store.set(_extractor.identifier, extractor);\n            this.player.debug(`${_extractor.identifier} extractor loaded!`);\n            this.emit('registered', this, extractor);\n            await extractor.activate();\n            this.player.debug(`${_extractor.identifier} extractor activated!`);\n            this.emit('activate', this, extractor);\n        } catch (e) {\n            this.store.delete(_extractor.identifier);\n            this.player.debug(`${_extractor.identifier} extractor failed to activate! Error: ${e}`);\n            this.emit('error', this, extractor, e as Error);\n        }\n    }\n\n    /**\n     * Unregister single extractor\n     * @param _extractor The extractor to unregister\n     */\n    public async unregister<K extends string | BaseExtractor>(_extractor: K) {\n        const extractor = typeof _extractor === 'string' ? this.store.get(_extractor) : this.store.find((r) => r === _extractor);\n        if (!extractor) return;\n\n        try {\n            const key = extractor.identifier || this.store.findKey((e) => e === extractor)!;\n            this.store.delete(key);\n            this.player.debug(`${extractor.identifier} extractor disabled!`);\n            this.emit('unregistered', this, extractor);\n            await extractor.deactivate();\n            this.player.debug(`${extractor.identifier} extractor deactivated!`);\n            this.emit('deactivate', this, extractor);\n        } catch (e) {\n            this.player.debug(`${extractor.identifier} extractor failed to deactivate!`);\n            this.emit('error', this, extractor, e as Error);\n        }\n    }\n\n    /**\n     * Unregister all extractors\n     */\n    public async unregisterAll() {\n        try {\n            await Promise.all(this.store.map((e) => this.unregister(e)));\n        } catch {\n            // do nothing\n        }\n    }\n\n    /**\n     * Run all the extractors\n     * @param fn The runner function\n     * @param filterBlocked Filter blocked extractors\n     */\n    public async run<T = unknown>(fn: ExtractorExecutionFN<T>, filterBlocked = true) {\n        const blocked = this.player.options.blockExtractors ?? [];\n        for (const ext of this.store.values()) {\n            if (filterBlocked && blocked.some((e) => e === ext.identifier)) continue;\n            this.player.debug(`Executing extractor ${ext.identifier}...`);\n            const result = await fn(ext).catch((e: Error) => {\n                this.player.debug(`Extractor ${ext.identifier} failed with error: ${e}`);\n                return false;\n            });\n            if (result) {\n                this.player.debug(`Extractor ${ext.identifier} executed successfully!`);\n\n                return {\n                    extractor: ext,\n                    result\n                } as ExtractorExecutionResult<T>;\n            }\n        }\n\n        return null;\n    }\n}\n\nexport interface ExtractorExecutionResult<T = unknown> {\n    extractor: BaseExtractor;\n    result: T;\n}\nexport type ExtractorExecutionFN<T = unknown> = (extractor: BaseExtractor) => Promise<T | boolean>;\n","import { EqualizerBand, PCMFilters, BiquadFilters } from '@discord-player/equalizer';\nimport { Collection, QueueStrategy } from '@discord-player/utils';\nimport { GuildResolvable } from 'discord.js';\nimport { Player } from '../Player';\nimport { GuildQueue, OnAfterCreateStreamHandler, OnBeforeCreateStreamHandler } from './GuildQueue';\nimport { FiltersName, QueueRepeatMode } from '../types/types';\nimport { getGlobalRegistry } from '../utils/__internal__';\n\nexport interface GuildNodeCreateOptions<T = unknown> {\n    strategy?: QueueStrategy;\n    volume?: number | boolean;\n    equalizer?: EqualizerBand[] | boolean;\n    a_filter?: PCMFilters[] | boolean;\n    biquad?: BiquadFilters | boolean;\n    resampler?: number | boolean;\n    disableHistory?: boolean;\n    skipOnNoStream?: boolean;\n    onBeforeCreateStream?: OnBeforeCreateStreamHandler;\n    onAfterCreateStream?: OnAfterCreateStreamHandler;\n    repeatMode?: QueueRepeatMode;\n    leaveOnEmpty?: boolean;\n    leaveOnEmptyCooldown?: number;\n    leaveOnEnd?: boolean;\n    leaveOnEndCooldown?: number;\n    leaveOnStop?: boolean;\n    leaveOnStopCooldown?: number;\n    metadata?: T | null;\n    selfDeaf?: boolean;\n    connectionTimeout?: number;\n    defaultFFmpegFilters?: FiltersName[];\n    bufferingTimeout?: number;\n    noEmitInsert?: boolean;\n}\n\nexport type NodeResolvable = GuildQueue | GuildResolvable;\n\nexport class GuildNodeManager<Meta = unknown> {\n    public cache = new Collection<string, GuildQueue>();\n    public constructor(public player: Player) {}\n\n    /**\n     * Create guild queue if it does not exist\n     * @param guild The guild which will be the owner of the queue\n     * @param options Queue initializer options\n     */\n    public create<T = Meta>(guild: GuildResolvable, options: GuildNodeCreateOptions<T> = {}): GuildQueue<T> {\n        const server = this.player.client.guilds.resolve(guild);\n        if (!server) {\n            throw new Error('Invalid or unknown guild');\n        }\n\n        if (this.cache.has(server.id)) {\n            return this.cache.get(server.id) as GuildQueue<T>;\n        }\n\n        options.strategy ??= 'FIFO';\n        options.volume ??= 100;\n        options.equalizer ??= [];\n        options.a_filter ??= [];\n        options.disableHistory ??= false;\n        options.skipOnNoStream ??= false;\n        options.leaveOnEmpty ??= true;\n        options.leaveOnEmptyCooldown ??= 0;\n        options.leaveOnEnd ??= true;\n        options.leaveOnEndCooldown ??= 0;\n        options.leaveOnStop ??= true;\n        options.leaveOnStopCooldown ??= 0;\n        options.resampler ??= 48000;\n        options.selfDeaf ??= true;\n        options.connectionTimeout ??= this.player.options.connectionTimeout;\n        options.bufferingTimeout ??= 1000;\n\n        if (getGlobalRegistry().has('@[onBeforeCreateStream]') && !options.onBeforeCreateStream) {\n            options.onBeforeCreateStream = getGlobalRegistry().get('@[onBeforeCreateStream]') as OnBeforeCreateStreamHandler;\n        }\n\n        if (getGlobalRegistry().has('@[onAfterCreateStream]') && !options.onAfterCreateStream) {\n            options.onAfterCreateStream = getGlobalRegistry().get('@[onAfterCreateStream]') as OnAfterCreateStreamHandler;\n        }\n\n        const queue = new GuildQueue<T>(this.player, {\n            guild: server,\n            queueStrategy: options.strategy,\n            volume: options.volume,\n            equalizer: options.equalizer,\n            filterer: options.a_filter,\n            biquad: options.biquad,\n            resampler: options.resampler,\n            disableHistory: options.disableHistory,\n            skipOnNoStream: options.skipOnNoStream,\n            onBeforeCreateStream: options.onBeforeCreateStream,\n            onAfterCreateStream: options.onAfterCreateStream,\n            repeatMode: options.repeatMode,\n            leaveOnEmpty: options.leaveOnEmpty,\n            leaveOnEmptyCooldown: options.leaveOnEmptyCooldown,\n            leaveOnEnd: options.leaveOnEnd,\n            leaveOnEndCooldown: options.leaveOnEndCooldown,\n            leaveOnStop: options.leaveOnStop,\n            leaveOnStopCooldown: options.leaveOnStopCooldown,\n            metadata: options.metadata,\n            connectionTimeout: options.connectionTimeout ?? 120_000,\n            selfDeaf: options.selfDeaf,\n            ffmpegFilters: options.defaultFFmpegFilters ?? [],\n            bufferingTimeout: options.bufferingTimeout,\n            noEmitInsert: options.noEmitInsert ?? false\n        });\n\n        this.cache.set(server.id, queue);\n\n        return queue;\n    }\n\n    /**\n     * Get existing queue\n     * @param node Queue resolvable\n     */\n    public get<T = Meta>(node: NodeResolvable) {\n        const queue = this.resolve(node);\n        if (!queue) return null;\n\n        return (this.cache.get(queue.id) as GuildQueue<T>) || null;\n    }\n\n    /**\n     * Check if a queue exists\n     * @param node Queue resolvable\n     */\n    public has(node: NodeResolvable) {\n        const id = node instanceof GuildQueue ? node.id : this.player.client.guilds.resolveId(node)!;\n        return this.cache.has(id);\n    }\n\n    /**\n     * Delete queue\n     * @param node Queue resolvable\n     */\n    public delete(node: NodeResolvable) {\n        const queue = this.resolve(node);\n        if (!queue) throw new Error('Cannot delete non-existing queue');\n\n        queue.node.stop(true);\n        queue.connection?.removeAllListeners();\n        queue.dispatcher?.removeAllListeners();\n        queue.dispatcher?.disconnect();\n        queue.timeouts.forEach((tm) => clearTimeout(tm));\n        queue.history.clear();\n        queue.tracks.clear();\n\n        return this.cache.delete(queue.id);\n    }\n\n    /**\n     * Resolve queue\n     * @param node Queue resolvable\n     */\n    public resolve<T = Meta>(node: NodeResolvable) {\n        if (node instanceof GuildQueue) {\n            return node;\n        }\n\n        return this.cache.get(this.player.client.guilds.resolveId(node)!) as GuildQueue<T> | undefined;\n    }\n\n    /**\n     * Resolve queue id\n     * @param node Queue resolvable\n     */\n    public resolveId(node: NodeResolvable) {\n        const q = this.resolve(node);\n        return q?.id || null;\n    }\n}\n","import { Player } from '../Player';\nimport { ChannelType, Guild, GuildVoiceChannelResolvable, VoiceBasedChannel, VoiceState } from 'discord.js';\nimport { Collection, Queue, QueueStrategy } from '@discord-player/utils';\nimport { BiquadFilters, EqualizerBand, PCMFilters } from '@discord-player/equalizer';\nimport { Track, TrackResolvable } from './Track';\nimport { StreamDispatcher } from '../VoiceInterface/StreamDispatcher';\nimport { AudioResource, StreamType } from '@discordjs/voice';\nimport { Util } from '../utils/Util';\nimport { Playlist } from './Playlist';\nimport { GuildQueueHistory } from './GuildQueueHistory';\nimport { GuildQueuePlayerNode } from './GuildQueuePlayerNode';\nimport { GuildQueueAudioFilters } from './GuildQueueAudioFilters';\nimport { Readable } from 'stream';\nimport { FiltersName, QueueRepeatMode, SearchQueryType } from '../types/types';\nimport { setTimeout } from 'timers';\nimport { GuildQueueStatistics } from './GuildQueueStatistics';\nimport { TypeUtil } from '../utils/TypeUtil';\n\nexport interface GuildNodeInit<Meta = unknown> {\n    guild: Guild;\n    queueStrategy: QueueStrategy;\n    equalizer: EqualizerBand[] | boolean;\n    volume: number | boolean;\n    biquad: BiquadFilters | boolean | undefined;\n    resampler: number | boolean;\n    filterer: PCMFilters[] | boolean;\n    ffmpegFilters: FiltersName[];\n    disableHistory: boolean;\n    skipOnNoStream: boolean;\n    onBeforeCreateStream?: OnBeforeCreateStreamHandler;\n    onAfterCreateStream?: OnAfterCreateStreamHandler;\n    repeatMode?: QueueRepeatMode;\n    leaveOnEmpty: boolean;\n    leaveOnEmptyCooldown: number;\n    leaveOnEnd: boolean;\n    leaveOnEndCooldown: number;\n    leaveOnStop: boolean;\n    leaveOnStopCooldown: number;\n    connectionTimeout: number;\n    selfDeaf?: boolean;\n    metadata?: Meta | null;\n    bufferingTimeout: number;\n    noEmitInsert: boolean;\n}\n\nexport interface VoiceConnectConfig {\n    deaf?: boolean;\n    timeout?: number;\n}\n\nexport interface PostProcessedResult {\n    stream: Readable;\n    type: StreamType;\n}\n\nexport type OnBeforeCreateStreamHandler = (track: Track, queryType: SearchQueryType, queue: GuildQueue) => Promise<Readable | null>;\nexport type OnAfterCreateStreamHandler = (stream: Readable, queue: GuildQueue) => Promise<PostProcessedResult | null>;\n\nexport type PlayerTriggeredReason = 'filters' | 'normal';\n\nexport enum GuildQueueEvent {\n    /**\n     * Emitted when audio track is added to the queue\n     */\n    audioTrackAdd = 'audioTrackadd',\n    /**\n     * Emitted when audio tracks were added to the queue\n     */\n    audioTracksAdd = 'audioTracksAdd',\n    /**\n     * Emitted when audio track is removed from the queue\n     */\n    audioTrackRemove = 'audioTrackRemove',\n    /**\n     * Emitted when audio tracks are removed from the queue\n     */\n    audioTracksRemove = 'audioTracksRemove',\n    /**\n     * Emitted when a connection is created\n     */\n    connection = 'connection',\n    /**\n     * Emitted when the bot is disconnected from the channel\n     */\n    disconnect = 'disconnect',\n    /**\n     * Emitted when the queue sends a debug info\n     */\n    debug = 'debug',\n    /**\n     * Emitted when the queue encounters error\n     */\n    error = 'error',\n    /**\n     * Emitted when the voice channel is empty\n     */\n    emptyChannel = 'emptyChannel',\n    /**\n     * Emitted when the queue is empty\n     */\n    emptyQueue = 'emptyQueue',\n    /**\n     * Emitted when the audio player starts streaming audio track\n     */\n    playerStart = 'playerStart',\n    /**\n     * Emitted when the audio player errors while streaming audio track\n     */\n    playerError = 'playerError',\n    /**\n     * Emitted when the audio player finishes streaming audio track\n     */\n    playerFinish = 'playerFinish',\n    /**\n     * Emitted when the audio player skips current track\n     */\n    playerSkip = 'playerSkip',\n    /**\n     * Emitted when the audio player is triggered\n     */\n    playerTrigger = 'playerTrigger',\n    /**\n     * Emitted when the voice state is updated. Consuming this event may disable default voice state update handler if `Player.isVoiceStateHandlerLocked()` returns `false`.\n     */\n    voiceStateUpdate = 'voiceStateUpdate'\n}\n\nexport interface GuildQueueEvents<Meta = unknown> {\n    /**\n     * Emitted when audio track is added to the queue\n     * @param queue The queue where this event occurred\n     * @param track The track\n     */\n    audioTrackAdd: (queue: GuildQueue<Meta>, track: Track) => unknown;\n    /**\n     * Emitted when audio tracks were added to the queue\n     * @param queue The queue where this event occurred\n     * @param tracks The tracks array\n     */\n    audioTracksAdd: (queue: GuildQueue<Meta>, track: Track[]) => unknown;\n    /**\n     * Emitted when audio track is removed from the queue\n     * @param queue The queue where this event occurred\n     * @param track The track\n     */\n    audioTrackRemove: (queue: GuildQueue<Meta>, track: Track) => unknown;\n    /**\n     * Emitted when audio tracks are removed from the queue\n     * @param queue The queue where this event occurred\n     * @param track The track\n     */\n    audioTracksRemove: (queue: GuildQueue<Meta>, track: Track[]) => unknown;\n    /**\n     * Emitted when a connection is created\n     * @param queue The queue where this event occurred\n     */\n    connection: (queue: GuildQueue<Meta>) => unknown;\n    /**\n     * Emitted when the bot is disconnected from the channel\n     * @param queue The queue where this event occurred\n     */\n    disconnect: (queue: GuildQueue<Meta>) => unknown;\n    /**\n     * Emitted when the queue sends a debug info\n     * @param queue The queue where this event occurred\n     * @param message The debug message\n     */\n    debug: (queue: GuildQueue<Meta>, message: string) => unknown;\n    /**\n     * Emitted when the queue encounters error\n     * @param queue The queue where this event occurred\n     * @param error The error\n     */\n    error: (queue: GuildQueue<Meta>, error: Error) => unknown;\n    /**\n     * Emitted when the voice channel is empty\n     * @param queue The queue where this event occurred\n     */\n    emptyChannel: (queue: GuildQueue<Meta>) => unknown;\n    /**\n     * Emitted when the queue is empty\n     * @param queue The queue where this event occurred\n     */\n    emptyQueue: (queue: GuildQueue<Meta>) => unknown;\n    /**\n     * Emitted when the audio player starts streaming audio track\n     * @param queue The queue where this event occurred\n     * @param track The track that is being streamed\n     */\n    playerStart: (queue: GuildQueue<Meta>, track: Track) => unknown;\n    /**\n     * Emitted when the audio player errors while streaming audio track\n     * @param queue The queue where this event occurred\n     * @param error The error\n     * @param track The track that is being streamed\n     */\n    playerError: (queue: GuildQueue<Meta>, error: Error, track: Track) => unknown;\n    /**\n     * Emitted when the audio player finishes streaming audio track\n     * @param queue The queue where this event occurred\n     * @param track The track that was being streamed\n     */\n    playerFinish: (queue: GuildQueue<Meta>, track: Track) => unknown;\n    /**\n     * Emitted when the audio player skips current track\n     * @param queue The queue where this event occurred\n     * @param track The track that was skipped\n     */\n    playerSkip: (queue: GuildQueue<Meta>, track: Track) => unknown;\n    /**\n     * Emitted when the audio player is triggered\n     * @param queue The queue where this event occurred\n     * @param track The track which was played in this event\n     */\n    playerTrigger: (queue: GuildQueue<Meta>, track: Track, reason: PlayerTriggeredReason) => unknown;\n    /**\n     * Emitted when the voice state is updated. Consuming this event may disable default voice state update handler if `Player.isVoiceStateHandlerLocked()` returns `false`.\n     * @param queue The queue where this event occurred\n     * @param oldState The old voice state\n     * @param newState The new voice state\n     */\n    voiceStateUpdate: (queue: GuildQueue<Meta>, oldState: VoiceState, newState: VoiceState) => unknown;\n}\n\nexport class GuildQueue<Meta = unknown> {\n    #transitioning = false;\n    #initializing = false;\n    #deleted = false;\n    #initializingPromises: Array<(value: boolean | PromiseLike<boolean>) => void> = [];\n    private __current: Track | null = null;\n    public tracks: Queue<Track>;\n    public history = new GuildQueueHistory<Meta>(this);\n    public dispatcher: StreamDispatcher | null = null;\n    public node = new GuildQueuePlayerNode<Meta>(this);\n    public filters = new GuildQueueAudioFilters<Meta>(this);\n    public onBeforeCreateStream: OnBeforeCreateStreamHandler = async () => null;\n    public onAfterCreateStream: OnAfterCreateStreamHandler = async (stream) => ({\n        stream,\n        type: StreamType.Raw\n    });\n    public repeatMode = QueueRepeatMode.OFF;\n    public timeouts = new Collection<string, NodeJS.Timeout>();\n    public stats = new GuildQueueStatistics<Meta>(this);\n\n    public constructor(public player: Player, public options: GuildNodeInit<Meta>) {\n        this.tracks = new Queue<Track>(options.queueStrategy);\n        if (TypeUtil.isFunction(options.onBeforeCreateStream)) this.onBeforeCreateStream = options.onBeforeCreateStream;\n        if (TypeUtil.isFunction(options.onAfterCreateStream)) this.onAfterCreateStream = options.onAfterCreateStream;\n        if (!TypeUtil.isNullish(options.repeatMode)) this.repeatMode = options.repeatMode;\n\n        options.selfDeaf ??= true;\n\n        if (!TypeUtil.isNullish(this.options.biquad) && !TypeUtil.isBoolean(this.options.biquad)) {\n            this.filters._lastFiltersCache.biquad = this.options.biquad;\n        }\n\n        if (Array.isArray(this.options.equalizer)) {\n            this.filters._lastFiltersCache.equalizer = this.options.equalizer;\n        }\n\n        if (Array.isArray(this.options.filterer)) {\n            this.filters._lastFiltersCache.filters = this.options.filterer;\n        }\n\n        if (TypeUtil.isNumber(this.options.resampler)) {\n            this.filters._lastFiltersCache.sampleRate = this.options.resampler;\n        }\n\n        if (TypeUtil.isArray(this.options.ffmpegFilters)) {\n            this.filters.ffmpeg.setDefaults(this.options.ffmpegFilters);\n        }\n\n        this.debug(`GuildQueue initialized for guild ${this.options.guild.name} (ID: ${this.options.guild.id})`);\n    }\n\n    /**\n     * Estimated duration of this queue in ms\n     */\n    public get estimatedDuration() {\n        return this.tracks.store.reduce((a, c) => a + c.durationMS, 0);\n    }\n\n    /**\n     * Formatted duration of this queue\n     */\n    public get durationFormatted() {\n        return Util.buildTimeCode(Util.parseMS(this.estimatedDuration));\n    }\n\n    /**\n     * The voice receiver for this queue\n     */\n    public get voiceReceiver() {\n        return this.dispatcher?.receiver ?? null;\n    }\n\n    /**\n     * Write a debug message to this queue\n     * @param m The message to write\n     */\n    public debug(m: string) {\n        this.player.events.emit('debug', this, m);\n    }\n\n    /**\n     * The metadata of this queue\n     */\n    public get metadata() {\n        return this.options.metadata!;\n    }\n\n    public set metadata(m: Meta) {\n        this.options.metadata = m;\n    }\n\n    /**\n     * Set metadata for this queue\n     * @param m Metadata to set\n     */\n    public setMetadata(m: Meta) {\n        this.options.metadata = m;\n    }\n\n    /**\n     * Indicates if this queue is currently initializing\n     */\n    public get initializing() {\n        return this.#initializing;\n    }\n\n    public set initializing(v: boolean) {\n        this.#initializing = v;\n        if (v) this.#resolveInitializerAwaiters();\n    }\n\n    /**\n     * Indicates current track of this queue\n     */\n    public get currentTrack() {\n        return this.dispatcher?.audioResource?.metadata || this.__current;\n    }\n\n    /**\n     * Indicates if this queue was deleted previously\n     */\n    public get deleted() {\n        return this.#deleted;\n    }\n\n    /**\n     * The voice channel of this queue\n     */\n    public get channel() {\n        return this.dispatcher?.channel || null;\n    }\n\n    public set channel(c: VoiceBasedChannel | null) {\n        if (this.dispatcher) {\n            if (c) {\n                this.dispatcher.channel = c;\n            } else {\n                this.delete();\n            }\n        }\n    }\n\n    /**\n     * The voice connection of this queue\n     */\n    public get connection() {\n        return this.dispatcher?.voiceConnection || null;\n    }\n\n    /**\n     * The guild this queue belongs to\n     */\n    public get guild() {\n        return this.options.guild;\n    }\n\n    /**\n     * The id of this queue\n     */\n    public get id() {\n        return this.guild.id;\n    }\n\n    /**\n     * Set transition mode for this queue\n     * @param state The state to set\n     */\n    public setTransitioning(state: boolean) {\n        this.#transitioning = state;\n    }\n\n    /**\n     * if this queue is currently under transition mode\n     */\n    public isTransitioning() {\n        return this.#transitioning;\n    }\n\n    /**\n     * Set repeat mode for this queue\n     * @param mode The repeat mode to apply\n     */\n    public setRepeatMode(mode: QueueRepeatMode) {\n        this.repeatMode = mode;\n    }\n\n    /**\n     * Gets the size of the queue\n     */\n    public get size() {\n        return this.tracks.size;\n    }\n\n    /**\n     * The size of this queue\n     */\n    public getSize() {\n        return this.size;\n    }\n\n    /**\n     * Clear this queue\n     */\n    public clear() {\n        this.tracks.clear();\n        this.history.clear();\n    }\n\n    /**\n     * Check if this queue has no tracks left in it\n     */\n    public isEmpty() {\n        return this.tracks.size < 1;\n    }\n\n    /**\n     * Check if this queue currently holds active audio resource\n     */\n    public isPlaying() {\n        return this.dispatcher?.audioResource != null && !this.dispatcher.audioResource.ended;\n    }\n\n    /**\n     * Add track to the queue. This will emit `audioTracksAdd` when multiple tracks are added, otherwise `audioTrackAdd`.\n     * @param track Track or playlist or array of tracks to add\n     */\n    public addTrack(track: Track | Track[] | Playlist) {\n        const toAdd = track instanceof Playlist ? track.tracks : track;\n        this.tracks.add(toAdd);\n        const isMulti = Array.isArray(toAdd);\n\n        if (isMulti) {\n            this.player.events.emit('audioTracksAdd', this, toAdd);\n        } else {\n            this.player.events.emit('audioTrackAdd', this, toAdd);\n        }\n    }\n\n    /**\n     * Remove a track from queue\n     * @param track The track to remove\n     */\n    public removeTrack(track: TrackResolvable) {\n        return this.node.remove(track);\n    }\n\n    /**\n     * Inserts the track to the given index\n     * @param track The track to insert\n     * @param index The index to insert the track at (defaults to 0)\n     */\n    public insertTrack(track: Track, index = 0): void {\n        return this.node.insert(track, index);\n    }\n\n    /**\n     * Moves a track in the queue\n     * @param from The track to move\n     * @param to The position to move to\n     */\n    public moveTrack(track: TrackResolvable, index = 0): void {\n        return this.node.move(track, index);\n    }\n\n    /**\n     * Copy a track in the queue\n     * @param from The track to clone\n     * @param to The position to clone at\n     */\n    public copyTrack(track: TrackResolvable, index = 0): void {\n        return this.node.copy(track, index);\n    }\n\n    /**\n     * Swap two tracks in the queue\n     * @param src The first track to swap\n     * @param dest The second track to swap\n     */\n    public swapTracks(src: TrackResolvable, dest: TrackResolvable): void {\n        return this.node.swap(src, dest);\n    }\n\n    /**\n     * Connect to a voice channel\n     * @param channelResolvable The voice channel to connect to\n     * @param options Join config\n     */\n    public async connect(channelResolvable: GuildVoiceChannelResolvable, options: VoiceConnectConfig = {}) {\n        const channel = this.player.client.channels.resolve(channelResolvable);\n        if (!channel || !channel.isVoiceBased()) {\n            throw new Error(`Expected a voice based channel (type ${ChannelType.GuildVoice}/${ChannelType.GuildStageVoice}), received ${channel?.type}`);\n        }\n\n        this.debug(`Connecting to ${channel.type === ChannelType.GuildStageVoice ? 'stage' : 'voice'} channel ${channel.name} (ID: ${channel.id})`);\n\n        if (this.dispatcher) {\n            this.debug('Destroying old connection');\n            this.#removeListeners(this.dispatcher);\n            this.dispatcher.disconnect();\n        }\n\n        this.dispatcher = await this.player.voiceUtils.connect(channel, {\n            deaf: options.deaf ?? this.options.selfDeaf ?? true,\n            maxTime: options?.timeout ?? this.options.connectionTimeout ?? 120_000,\n            queue: this\n        });\n\n        this.player.events.emit('connection', this);\n\n        if (this.channel!.type === ChannelType.GuildStageVoice) {\n            await this.channel!.guild.members.me!.voice.setSuppressed(false).catch(async () => {\n                return await this.channel!.guild.members.me!.voice.setRequestToSpeak(true).catch(Util.noop);\n            });\n        }\n\n        this.#attachListeners(this.dispatcher);\n\n        return this;\n    }\n\n    /**\n     * The voice connection latency of this queue\n     */\n    public get ping() {\n        return this.connection?.ping.udp ?? -1;\n    }\n\n    /**\n     * Delete this queue\n     */\n    public delete() {\n        if (this.player.nodes.delete(this.id)) {\n            this.#deleted = true;\n        }\n    }\n\n    /**\n     * Revives this queue\n     * @returns\n     */\n    public revive() {\n        if (!this.deleted || this.player.nodes.has(this.id)) return;\n        this.#deleted = false;\n        this.player.nodes.cache.set(this.id, this);\n    }\n\n    /**\n     * Wait for this queue to initialize\n     */\n    public awaitInitialization() {\n        return new Promise<boolean>((r) => {\n            if (!this.#initializing) return r(true);\n            this.#initializingPromises.push(r);\n        });\n    }\n\n    /**\n     * Set self deaf\n     * @param mode On/Off state\n     * @param reason Reason\n     */\n    public setSelfDeaf(mode?: boolean, reason?: string) {\n        return this.guild.members.me!.voice.setDeaf(mode, reason);\n    }\n\n    /**\n     * Set self mute\n     * @param mode On/Off state\n     * @param reason Reason\n     */\n    public setSelfMute(mode?: boolean, reason?: string) {\n        return this.guild.members.me!.voice.setMute(mode, reason);\n    }\n\n    #attachListeners(dispatcher: StreamDispatcher) {\n        dispatcher.on('error', (e) => this.player.events.emit('error', this, e));\n        dispatcher.on('debug', (m) => this.player.events.emit('debug', this, m));\n        dispatcher.on('finish', (r) => this.#performFinish(r));\n        dispatcher.on('start', (r) => this.#performStart(r));\n        dispatcher.on('dsp', (f) => {\n            this.filters._lastFiltersCache.filters = f;\n        });\n        dispatcher.on('biquad', (f) => {\n            this.filters._lastFiltersCache.biquad = f;\n        });\n        dispatcher.on('eqBands', (f) => {\n            this.filters._lastFiltersCache.equalizer = f;\n        });\n        dispatcher.on('volume', (f) => {\n            this.filters._lastFiltersCache.volume = f;\n        });\n    }\n\n    #removeListeners(dispatcher: StreamDispatcher) {\n        dispatcher.removeAllListeners();\n    }\n\n    #performStart(resource?: AudioResource<Track>) {\n        const track = resource?.metadata || this.currentTrack;\n        const reason = this.isTransitioning() ? 'filters' : 'normal';\n\n        this.debug(\n            `Player triggered for Track ${JSON.stringify({\n                title: track?.title,\n                reason\n            })}`\n        );\n\n        this.player.events.emit('playerTrigger', this, track!, reason);\n        if (track && !this.isTransitioning()) this.player.events.emit('playerStart', this, track);\n        this.setTransitioning(false);\n        this.initializing = false;\n    }\n\n    #performFinish(resource?: AudioResource<Track>) {\n        const track = resource?.metadata || this.currentTrack;\n\n        this.debug(\n            `Track ${JSON.stringify({\n                title: track?.title,\n                isTransitionMode: this.isTransitioning()\n            })} was marked as finished`\n        );\n\n        if (track && !this.isTransitioning()) {\n            this.debug('Adding track to history and emitting finish event since transition mode is disabled...');\n            this.history.push(track);\n            this.node.resetProgress();\n            this.player.events.emit('playerFinish', this, track);\n            if (this.tracks.size < 1 && this.repeatMode === QueueRepeatMode.OFF) {\n                this.debug('No more tracks left in the queue to play and repeat mode is off, initiating #emitEnd()');\n                this.#emitEnd();\n            } else {\n                if (this.repeatMode === QueueRepeatMode.TRACK) {\n                    this.debug('Repeat mode is set to track, repeating last track from the history...');\n                    this.__current = this.history.tracks.dispatch() || track;\n                    return this.node.play(this.__current!, { queue: false });\n                }\n                if (this.repeatMode === QueueRepeatMode.QUEUE) {\n                    this.debug('Repeat mode is set to queue, moving last track from the history to current queue...');\n                    this.tracks.add(this.history.tracks.dispatch() || track);\n                }\n                if (!this.tracks.size) {\n                    if (this.repeatMode === QueueRepeatMode.AUTOPLAY) {\n                        this.debug('Repeat mode is set to autoplay, initiating autoplay handler...');\n                        this.#handleAutoplay(track);\n                        return;\n                    }\n                } else {\n                    this.debug('Initializing next track of the queue...');\n                    this.__current = this.tracks.dispatch()!;\n                    this.node.play(this.__current, {\n                        queue: false\n                    });\n                }\n            }\n        }\n    }\n\n    #emitEnd() {\n        this.__current = null;\n        this.player.events.emit('emptyQueue', this);\n        if (this.options.leaveOnEnd) {\n            const tm: NodeJS.Timeout = setTimeout(() => {\n                if (this.tracks.size) return clearTimeout(tm);\n                this.dispatcher?.disconnect();\n            }, this.options.leaveOnEndCooldown).unref();\n        }\n    }\n\n    async #handleAutoplay(track: Track) {\n        try {\n            this.debug(`Autoplay >> Finding related tracks for Track ${track.title} (${track.url}) [ext:${track.extractor?.identifier || 'N/A'}]`);\n            const tracks =\n                (await track.extractor?.getRelatedTracks(track))?.tracks ||\n                (\n                    await this.player.extractors.run(async (ext) => {\n                        this.debug(`Autoplay >> Querying extractor ${ext.identifier}`);\n                        const res = await ext.getRelatedTracks(track);\n                        if (!res.tracks.length) {\n                            this.debug(`Autoplay >> Extractor ${ext.identifier} failed to provide results.`);\n                            return false;\n                        }\n\n                        this.debug(`Autoplay >> Extractor ${ext.identifier} successfully returned results.`);\n\n                        return res.tracks;\n                    })\n                )?.result;\n            if (!tracks?.length) {\n                this.debug(`Autoplay >> No related tracks found.`);\n                throw 'no related tracks';\n            }\n\n            this.debug(`Autoplay >> Picking random track from first 5 tracks...`);\n            const nextTrack = Util.randomChoice(tracks.slice(0, 5));\n            await this.node.play(nextTrack, {\n                queue: false,\n                seek: 0,\n                transitionMode: false\n            });\n        } catch {\n            return this.#emitEnd();\n        }\n    }\n\n    #resolveInitializerAwaiters() {\n        this.#initializingPromises.forEach((p) => {\n            p(!this.#initializing);\n        });\n\n        this.#initializingPromises = [];\n    }\n}\n","import { Player } from '../Player';\nimport { Track } from './Track';\nimport { PlaylistInitData, PlaylistJSON, TrackJSON, TrackSource } from '../types/types';\nimport { Util } from '../utils/Util';\n\nexport class Playlist {\n    public readonly player: Player;\n    public tracks: Track[];\n    public title: string;\n    public description: string;\n    public thumbnail: string;\n    public type: 'album' | 'playlist';\n    public source: TrackSource;\n    public author: {\n        name: string;\n        url: string;\n    };\n    public id: string;\n    public url: string;\n    public readonly rawPlaylist?: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n\n    /**\n     * Playlist constructor\n     * @param {Player} player The player\n     * @param {PlaylistInitData} data The data\n     */\n    constructor(player: Player, data: PlaylistInitData) {\n        /**\n         * The player\n         * @name Playlist#player\n         * @type {Player}\n         * @readonly\n         */\n        this.player = player;\n\n        /**\n         * The tracks in this playlist\n         * @name Playlist#tracks\n         * @type {Track[]}\n         */\n        this.tracks = data.tracks ?? [];\n\n        /**\n         * The author of this playlist\n         * @name Playlist#author\n         * @type {object}\n         */\n        this.author = data.author;\n\n        /**\n         * The description\n         * @name Playlist#description\n         * @type {string}\n         */\n        this.description = data.description;\n\n        /**\n         * The thumbnail of this playlist\n         * @name Playlist#thumbnail\n         * @type {string}\n         */\n        this.thumbnail = data.thumbnail;\n\n        /**\n         * The playlist type:\n         * - `album`\n         * - `playlist`\n         * @name Playlist#type\n         * @type {string}\n         */\n        this.type = data.type;\n\n        /**\n         * The source of this playlist:\n         * - `youtube`\n         * - `soundcloud`\n         * - `spotify`\n         * - `arbitrary`\n         * @name Playlist#source\n         * @type {string}\n         */\n        this.source = data.source;\n\n        /**\n         * The playlist id\n         * @name Playlist#id\n         * @type {string}\n         */\n        this.id = data.id;\n\n        /**\n         * The playlist url\n         * @name Playlist#url\n         * @type {string}\n         */\n        this.url = data.url;\n\n        /**\n         * The playlist title\n         * @type {string}\n         */\n        this.title = data.title;\n\n        /**\n         * @name Playlist#rawPlaylist\n         * @type {any}\n         * @readonly\n         */\n    }\n\n    *[Symbol.iterator]() {\n        yield* this.tracks;\n    }\n\n    /**\n     * Estimated duration of this playlist\n     */\n    public get estimatedDuration() {\n        return this.tracks.reduce((p, c) => p + c.durationMS, 0);\n    }\n\n    /**\n     * Formatted estimated duration of this playlist\n     */\n    public get durationFormatted() {\n        return Util.buildTimeCode(Util.parseMS(this.estimatedDuration));\n    }\n\n    /**\n     * JSON representation of this playlist\n     * @param {boolean} [withTracks=true] If it should build json with tracks\n     * @returns {PlaylistJSON}\n     */\n    toJSON(withTracks = true) {\n        const payload = {\n            id: this.id,\n            url: this.url,\n            title: this.title,\n            description: this.description,\n            thumbnail: this.thumbnail,\n            type: this.type,\n            source: this.source,\n            author: this.author,\n            tracks: [] as TrackJSON[]\n        };\n\n        if (withTracks) payload.tracks = this.tracks.map((m) => m.toJSON(true));\n\n        return payload as PlaylistJSON;\n    }\n}\n","import { Queue } from '@discord-player/utils';\nimport { Track } from './Track';\nimport { GuildQueue } from './GuildQueue';\n\nexport class GuildQueueHistory<Meta = unknown> {\n    public tracks = new Queue<Track>('LIFO');\n    public constructor(public queue: GuildQueue<Meta>) {}\n\n    /**\n     * Current track in the queue\n     */\n    public get currentTrack() {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return this.queue.dispatcher?.audioResource?.metadata || ((this.queue as any).__current as Track | null);\n    }\n\n    /**\n     * Next track in the queue\n     */\n    public get nextTrack() {\n        return this.queue.tracks.at(0) || null;\n    }\n\n    /**\n     * Previous track in the queue\n     */\n    public get previousTrack() {\n        return this.tracks.at(0) || null;\n    }\n\n    /**\n     * If history is disabled\n     */\n    public get disabled() {\n        return this.queue.options.disableHistory;\n    }\n\n    /**\n     * Gets the size of the queue\n     */\n    public get size() {\n        return this.tracks.size;\n    }\n\n    public getSize() {\n        return this.size;\n    }\n\n    /**\n     * If history is empty\n     */\n    public isEmpty() {\n        return this.tracks.size < 1;\n    }\n\n    /**\n     * Add track to track history\n     * @param track The track to add\n     */\n    public push(track: Track | Track[]) {\n        if (this.disabled) return false;\n        this.tracks.add(track);\n        return true;\n    }\n\n    /**\n     * Clear history\n     */\n    public clear() {\n        this.tracks.clear();\n    }\n\n    /**\n     * Play the next track in the queue\n     */\n    public async next() {\n        const track = this.nextTrack;\n        if (!track) {\n            throw new Error('No next track in the queue');\n        }\n\n        this.queue.node.skip();\n    }\n\n    /**\n     * Play the previous track in the queue\n     */\n    public async previous(preserveCurrent = true) {\n        const track = this.tracks.dispatch();\n        if (!track) {\n            throw new Error('No previous track in the queue');\n        }\n\n        const current = this.currentTrack;\n\n        await this.queue.node.play(track, { queue: false });\n        if (current && preserveCurrent) this.queue.node.insert(current, 0);\n    }\n\n    /**\n     * Alias to [GuildQueueHistory].previous()\n     */\n    public back() {\n        return this.previous();\n    }\n}\n","import { AudioResource, StreamType } from '@discordjs/voice';\nimport { Readable } from 'stream';\nimport { PlayerProgressbarOptions, SearchQueryType } from '../types/types';\nimport { QueryResolver } from '../utils/QueryResolver';\nimport { Util } from '../utils/Util';\nimport { Track, TrackResolvable } from './Track';\nimport { GuildQueue } from './GuildQueue';\nimport { setTimeout as waitFor } from 'timers/promises';\n\nexport const FFMPEG_SRATE_REGEX = /asetrate=\\d+\\*(\\d(\\.\\d)?)/;\n\nexport interface ResourcePlayOptions {\n    queue?: boolean;\n    seek?: number;\n    transitionMode?: boolean;\n}\n\nexport interface PlayerTimestamp {\n    current: {\n        label: string;\n        value: number;\n    };\n    total: {\n        label: string;\n        value: number;\n    };\n    progress: number;\n}\n\nexport class GuildQueuePlayerNode<Meta = unknown> {\n    #progress = 0;\n    public constructor(public queue: GuildQueue<Meta>) {}\n\n    /**\n     * If the player is currently in idle mode\n     */\n    public isIdle() {\n        return !!this.queue.dispatcher?.isIdle();\n    }\n\n    /**\n     * If the player is currently buffering the track\n     */\n    public isBuffering() {\n        return !!this.queue.dispatcher?.isBuffering();\n    }\n\n    /**\n     * If the player is currently playing a track\n     */\n    public isPlaying() {\n        return !!this.queue.dispatcher?.isPlaying();\n    }\n\n    /**\n     * If the player is currently paused\n     */\n    public isPaused() {\n        return !!this.queue.dispatcher?.isPaused();\n    }\n\n    /**\n     * Reset progress history\n     */\n    public resetProgress() {\n        this.#progress = 0;\n    }\n\n    /**\n     * The stream time for current session\n     */\n    public get streamTime() {\n        return this.queue.dispatcher?.streamTime ?? 0;\n    }\n\n    /**\n     * Current playback duration with history included\n     */\n    public get playbackTime() {\n        const dur = this.#progress + this.streamTime;\n\n        return dur;\n    }\n\n    /**\n     * Get duration multiplier\n     */\n    public getDurationMultiplier() {\n        const srateFilters = this.queue.filters.ffmpeg.toArray().filter((ff) => FFMPEG_SRATE_REGEX.test(ff));\n        const multipliers = srateFilters\n            .map((m) => {\n                return parseFloat(FFMPEG_SRATE_REGEX.exec(m)?.[1] as string);\n            })\n            .filter((f) => !isNaN(f));\n\n        return !multipliers.length ? 1 : multipliers.reduce((accumulator, current) => current + accumulator);\n    }\n\n    /**\n     * Estimated progress of the player\n     */\n    public get estimatedPlaybackTime() {\n        const dur = this.playbackTime;\n        return Math.round(this.getDurationMultiplier() * dur);\n    }\n\n    /**\n     * Estimated total duration of the player\n     */\n    public get estimatedDuration() {\n        const dur = this.queue.currentTrack?.durationMS ?? 0;\n\n        return Math.round(dur / this.getDurationMultiplier());\n    }\n\n    /**\n     * Get stream progress\n     * @param ignoreFilters Ignore filters\n     */\n    public getTimestamp(ignoreFilters = false): PlayerTimestamp | null {\n        if (!this.queue.currentTrack) return null;\n\n        const current = ignoreFilters ? this.playbackTime : this.estimatedPlaybackTime;\n        const total = ignoreFilters ? this.queue.currentTrack.durationMS : this.estimatedDuration;\n\n        return {\n            current: {\n                label: Util.buildTimeCode(Util.parseMS(current)),\n                value: current\n            },\n            total: {\n                label: Util.buildTimeCode(Util.parseMS(total)),\n                value: total\n            },\n            progress: Math.round((current / total) * 100)\n        };\n    }\n\n    /**\n     * Create progress bar for current progress\n     * @param options Progress bar options\n     */\n    public createProgressBar(options?: PlayerProgressbarOptions) {\n        const timestamp = this.getTimestamp();\n        if (!timestamp) return null;\n\n        const { indicator = '', length = 15, line = '', timecodes = true } = options || {};\n\n        if (isNaN(length) || length < 0 || !Number.isFinite(length)) throw new Error('invalid progressbar length');\n        const index = Math.round((timestamp.current.value / timestamp.total.value) * length);\n\n        if (index >= 1 && index <= length) {\n            const bar = line.repeat(length - 1).split('');\n            bar.splice(index, 0, indicator);\n            if (timecodes) {\n                return `${timestamp.current.label}  ${bar.join('')}  ${timestamp.total.label}`;\n            } else {\n                return `${bar.join('')}`;\n            }\n        } else {\n            if (timecodes) {\n                return `${timestamp.current.label}  ${indicator}${line.repeat(length - 1)}  ${timestamp.total.label}`;\n            } else {\n                return `${indicator}${line.repeat(length - 1)}`;\n            }\n        }\n    }\n\n    /**\n     * Seek the player\n     * @param duration The duration to seek to\n     */\n    public async seek(duration: number) {\n        if (!this.queue.currentTrack) return false;\n        return await this.queue.filters.triggerReplay(duration);\n    }\n\n    /**\n     * Current volume\n     */\n    public get volume() {\n        return this.queue.dispatcher?.volume ?? 100;\n    }\n\n    /**\n     * Set volume\n     * @param vol Volume amount to set\n     */\n    public setVolume(vol: number) {\n        if (!this.queue.dispatcher) return false;\n        const res = this.queue.dispatcher.setVolume(vol);\n        if (res) this.queue.filters._lastFiltersCache.volume = vol;\n        return res;\n    }\n\n    /**\n     * Set bit rate\n     * @param rate The bit rate to set\n     */\n    public setBitrate(rate: number | 'auto') {\n        this.queue.dispatcher?.audioResource?.encoder?.setBitrate(rate === 'auto' ? this.queue.channel?.bitrate ?? 64000 : rate);\n    }\n\n    /**\n     * Set paused state\n     * @param state The state\n     */\n    public setPaused(state: boolean) {\n        if (state) return this.queue.dispatcher?.pause(true) || false;\n        return this.queue.dispatcher?.resume() || false;\n    }\n\n    /**\n     * Pause the playback\n     */\n    public pause() {\n        return this.setPaused(true);\n    }\n\n    /**\n     * Resume the playback\n     */\n    public resume() {\n        return this.setPaused(false);\n    }\n\n    /**\n     * Skip current track\n     */\n    public skip() {\n        if (!this.queue.dispatcher) return false;\n        this.queue.setTransitioning(false);\n        this.queue.dispatcher.end();\n        return true;\n    }\n\n    /**\n     * Remove the given track from queue\n     * @param track The track to remove\n     */\n    public remove(track: TrackResolvable) {\n        const foundTrack = this.queue.tracks.find((t, idx) => {\n            if (track instanceof Track || typeof track === 'string') {\n                return (typeof track === 'string' ? track : track.id) === t.id;\n            }\n            if (typeof track === 'string') return track === t.id;\n            return idx === track;\n        });\n        if (!foundTrack) return null;\n\n        this.queue.tracks.removeOne((t) => t.id === foundTrack.id);\n\n        this.queue.player.events.emit('audioTrackRemove', this.queue, foundTrack);\n\n        return foundTrack;\n    }\n\n    /**\n     * Jump to specific track on the queue\n     * @param track The track to jump to without removing other tracks\n     */\n    public jump(track: TrackResolvable) {\n        const removed = this.remove(track);\n        if (!removed) return false;\n        this.queue.tracks.store.unshift(removed);\n        return this.skip();\n    }\n\n    /**\n     * Get track position\n     * @param track The track\n     */\n    public getTrackPosition(track: TrackResolvable): number {\n        return this.queue.tracks.toArray().findIndex((t, idx) => {\n            if (track instanceof Track || typeof track === 'string') {\n                return (typeof track === 'string' ? track : track.id) === t.id;\n            }\n            if (typeof track === 'string') return track === t.id;\n            return idx === track;\n        });\n    }\n\n    /**\n     * Skip to the given track, removing others on the way\n     * @param track The track to skip to\n     */\n    public skipTo(track: TrackResolvable) {\n        const idx = this.getTrackPosition(track);\n        if (idx < 0) return false;\n        const removed = this.remove(idx);\n        if (!removed) return false;\n        const toRemove = this.queue.tracks.store.filter((_, i) => i <= idx);\n        this.queue.tracks.store.splice(0, idx, removed);\n        this.queue.player.events.emit('audioTracksRemove', this.queue, toRemove);\n        return this.skip();\n    }\n\n    /**\n     * Insert a track on the given position in queue\n     * @param track The track to insert\n     * @param index The position to insert to, defaults to 0.\n     */\n    public insert(track: Track, index = 0) {\n        if (!(track instanceof Track)) throw new Error('invalid track');\n        this.queue.tracks.store.splice(index, 0, track);\n        if (!this.queue.options.noEmitInsert) this.queue.player.events.emit('audioTrackAdd', this.queue, track);\n    }\n\n    /**\n     * Moves a track in the queue\n     * @param from The track to move\n     * @param to The position to move to\n     */\n    public move(from: TrackResolvable, to: number) {\n        const removed = this.remove(from);\n        if (!removed) throw new Error('invalid track to move');\n        this.insert(removed, to);\n    }\n\n    /**\n     * Copy a track in the queue\n     * @param from The track to clone\n     * @param to The position to clone at\n     */\n    public copy(from: TrackResolvable, to: number) {\n        const src = this.queue.tracks.at(this.getTrackPosition(from));\n        if (!src) throw new Error('invalid track to copy');\n        this.insert(src, to);\n    }\n\n    /**\n     * Swap two tracks in the queue\n     * @param first The first track to swap\n     * @param second The second track to swap\n     */\n    public swap(first: TrackResolvable, second: TrackResolvable) {\n        const src = this.getTrackPosition(first);\n        if (src < 0) throw new Error('invalid src track to swap');\n\n        const dest = this.getTrackPosition(second);\n        if (dest < 0) throw new Error('invalid dest track to swap');\n\n        const srcT = this.queue.tracks.store[src];\n        const destT = this.queue.tracks.store[dest];\n\n        this.queue.tracks.store[src] = destT;\n        this.queue.tracks.store[dest] = srcT;\n    }\n\n    /**\n     * Stop the playback\n     * @param force Whether or not to forcefully stop the playback\n     */\n    public stop(force = false) {\n        this.queue.tracks.clear();\n        this.queue.history.clear();\n        if (!this.queue.dispatcher) return false;\n        this.queue.dispatcher.end();\n        if (force) {\n            this.queue.dispatcher.disconnect();\n            return true;\n        }\n        if (this.queue.options.leaveOnStop) {\n            const tm: NodeJS.Timeout = setTimeout(() => {\n                if (this.isPlaying() || this.queue.tracks.size) return clearTimeout(tm);\n                this.queue.dispatcher?.disconnect();\n            }, this.queue.options.leaveOnStopCooldown).unref();\n        }\n        return true;\n    }\n\n    /**\n     * Play raw audio resource\n     * @param resource The audio resource to play\n     */\n    public async playRaw(resource: AudioResource) {\n        await this.queue.dispatcher?.playStream(resource as AudioResource<Track>);\n    }\n\n    /**\n     * Play the given track\n     * @param res The track to play\n     * @param options Options for playing the track\n     */\n    public async play(res?: Track | null, options?: ResourcePlayOptions) {\n        if (!this.queue.dispatcher?.voiceConnection) {\n            throw new Error('No voice connection available');\n        }\n\n        this.queue.debug(`Received play request from guild ${this.queue.guild.name} (ID: ${this.queue.guild.id})`);\n\n        options = Object.assign(\n            {},\n            {\n                queue: this.queue.currentTrack != null,\n                transitionMode: false,\n                seek: 0\n            } as ResourcePlayOptions,\n            options\n        )!;\n\n        if (res && options.queue) {\n            this.queue.debug('Requested option requires to queue the track, adding the given track to queue instead...');\n            return this.queue.addTrack(res);\n        }\n\n        const track = res || this.queue.tracks.dispatch();\n        if (!track) {\n            throw new Error('Play request received but track was not provided');\n        }\n\n        if (this.queue.initializing) {\n            this.queue.debug('Queue is currently initializing another track, waiting...');\n            await this.queue.awaitInitialization();\n            this.queue.debug('Queue has finished initialization...');\n        }\n\n        this.queue.debug('Requested option requires to play the track, initializing...');\n        this.queue.initializing = true;\n\n        try {\n            this.queue.debug(`Initiating stream extraction process...`);\n            const src = track.raw?.source || track.source;\n            const qt: SearchQueryType = track.queryType || (src === 'spotify' ? 'spotifySong' : src === 'apple_music' ? 'appleMusicSong' : src);\n            this.queue.debug(`Executing onBeforeCreateStream hook (QueryType: ${qt})...`);\n            let stream = await this.queue.onBeforeCreateStream?.(track, qt || 'arbitrary', this.queue).catch(() => null);\n\n            if (!stream) {\n                this.queue.debug('Failed to get stream from onBeforeCreateStream!');\n                stream = (await this.#createGenericStream(track).catch(() => null)) as Readable;\n            }\n\n            if (!stream) {\n                const error = new Error('Could not extract stream for this track');\n                if (this.queue.options.skipOnNoStream) {\n                    this.queue.player.events.emit('playerSkip', this.queue, track);\n                    this.queue.player.events.emit('playerError', this.queue, error, track);\n                    this.queue.initializing = false;\n                    const nextTrack = this.queue.tracks.dispatch();\n                    if (nextTrack) this.play(null, { queue: false });\n                    return;\n                }\n\n                throw error;\n            }\n\n            if (typeof options.seek === 'number' && options.seek >= 0) {\n                this.#progress = options.seek;\n            } else {\n                this.#progress = 0;\n            }\n\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const cookies = track.raw?.source === 'youtube' ? (<any>this.queue.player.options.ytdlOptions?.requestOptions)?.headers?.cookie : undefined;\n            const pcmStream = this.#createFFmpegStream(stream, track, options.seek ?? 0, cookies);\n\n            if (options.transitionMode) {\n                this.queue.debug(`Transition mode detected, player will wait for buffering timeout to expire (Timeout: ${this.queue.options.bufferingTimeout}ms)`);\n                await waitFor(this.queue.options.bufferingTimeout);\n                this.queue.debug('Buffering timeout has expired!');\n            }\n\n            this.queue.debug(\n                `Preparing final stream config: ${JSON.stringify(\n                    {\n                        disableBiquad: this.queue.options.biquad === false,\n                        disableEqualizer: this.queue.options.equalizer === false,\n                        disableVolume: this.queue.options.volume === false,\n                        disableFilters: this.queue.options.filterer === false,\n                        disableResampler: this.queue.options.resampler === false,\n                        sampleRate: typeof this.queue.options.resampler === 'number' && this.queue.options.resampler > 0 ? this.queue.options.resampler : undefined,\n                        biquadFilter: this.queue.filters._lastFiltersCache.biquad || undefined,\n                        eq: this.queue.filters._lastFiltersCache.equalizer,\n                        defaultFilters: this.queue.filters._lastFiltersCache.filters,\n                        volume: this.queue.filters._lastFiltersCache.volume,\n                        transitionMode: !!options.transitionMode,\n                        ffmpegFilters: this.queue.filters.ffmpeg.toString(),\n                        seek: options.seek\n                    },\n                    null,\n                    2\n                )}`\n            );\n\n            const resource = await this.queue.dispatcher.createStream(pcmStream, {\n                disableBiquad: this.queue.options.biquad === false,\n                disableEqualizer: this.queue.options.equalizer === false,\n                disableVolume: this.queue.options.volume === false,\n                disableFilters: this.queue.options.filterer === false,\n                disableResampler: this.queue.options.resampler === false,\n                sampleRate: typeof this.queue.options.resampler === 'number' && this.queue.options.resampler > 0 ? this.queue.options.resampler : undefined,\n                biquadFilter: this.queue.filters._lastFiltersCache.biquad || undefined,\n                eq: this.queue.filters._lastFiltersCache.equalizer,\n                defaultFilters: this.queue.filters._lastFiltersCache.filters,\n                volume: this.queue.filters._lastFiltersCache.volume,\n                data: track,\n                type: StreamType.Raw\n            });\n\n            this.queue.setTransitioning(!!options.transitionMode);\n\n            await this.#performPlay(resource);\n            this.queue.initializing = false;\n        } catch (e) {\n            this.queue.debug(`Failed to initialize audio player: ${e}`);\n            this.queue.initializing = false;\n            throw e;\n        }\n    }\n\n    async #performPlay(resource: AudioResource<Track>) {\n        this.queue.debug('Initializing audio player...');\n        await this.queue.dispatcher!.playStream(resource);\n        this.queue.debug('Dispatching audio...');\n    }\n\n    async #createGenericStream(track: Track) {\n        this.queue.debug(`Attempting to extract stream for Track { title: ${track.title}, url: ${track.url} } using registered extractors`);\n        const streamInfo = await this.queue.player.extractors.run(async (extractor) => {\n            if (this.queue.player.options.blockStreamFrom?.some((ext) => ext === extractor.identifier)) return false;\n            const canStream = await extractor.validate(track.url, track.queryType || QueryResolver.resolve(track.url));\n            if (!canStream) return false;\n            return await extractor.stream(track);\n        }, false);\n        if (!streamInfo || !streamInfo.result) {\n            this.queue.debug(`Failed to extract stream for Track { title: ${track.title}, url: ${track.url} } using registered extractors`);\n            return null;\n        }\n\n        this.queue.debug(`Stream extraction was successful for Track { title: ${track.title}, url: ${track.url} } (Extractor: ${streamInfo.extractor.identifier})`);\n\n        const stream = streamInfo.result;\n        return stream;\n    }\n\n    #createFFmpegStream(stream: Readable | string, track: Track, seek = 0, cookies?: string) {\n        const ffmpegStream = this.queue.filters.ffmpeg\n            .createStream(stream, {\n                encoderArgs: this.queue.filters.ffmpeg.filters.length ? ['-af', this.queue.filters.ffmpeg.toString()] : [],\n                seek: seek / 1000,\n                fmt: 's16le',\n                cookies\n            })\n            .on('error', (err) => {\n                const m = `${err}`.toLowerCase();\n\n                this.queue.debug(`Stream closed due to an error from FFmpeg stream: ${err.stack || err.message || err}`);\n\n                if (m.includes('premature close') || m.includes('epipe')) return;\n\n                this.queue.player.events.emit('playerError', this.queue, err, track);\n            });\n\n        return ffmpegStream;\n    }\n}\n","import { YouTube } from 'youtube-sr';\nimport { QueryType } from '../types/types';\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nimport * as soundcloud from 'soundcloud-scraper';\n\n// #region scary things below *sigh*\nconst spotifySongRegex = /^https?:\\/\\/(?:embed\\.|open\\.)(?:spotify\\.com\\/)(?:track\\/|\\?uri=spotify:track:)((\\w|-){22})(\\?si=.+)?$/;\nconst spotifyPlaylistRegex = /^https?:\\/\\/(?:embed\\.|open\\.)(?:spotify\\.com\\/)(?:playlist\\/|\\?uri=spotify:playlist:)((\\w|-){22})(\\?si=.+)?$/;\nconst spotifyAlbumRegex = /^https?:\\/\\/(?:embed\\.|open\\.)(?:spotify\\.com\\/)(?:album\\/|\\?uri=spotify:album:)((\\w|-){22})(\\?si=.+)?$/;\nconst vimeoRegex = /^(http|https)?:\\/\\/(www\\.|player\\.)?vimeo\\.com\\/(?:channels\\/(?:\\w+\\/)?|groups\\/([^/]*)\\/videos\\/|video\\/|)(\\d+)(?:|\\/\\?)$/;\nconst reverbnationRegex = /^https:\\/\\/(www.)?reverbnation.com\\/(.+)\\/song\\/(.+)$/;\nconst attachmentRegex = /^https?:\\/\\/.+$/;\nconst appleMusicSongRegex = /^https?:\\/\\/music\\.apple\\.com\\/.+?\\/(song|album)\\/.+?(\\/.+?\\?i=|\\/)([0-9]+)$/;\nconst appleMusicPlaylistRegex = /^https?:\\/\\/music\\.apple\\.com\\/.+?\\/playlist\\/.+\\/pl\\.(u-)?[a-zA-Z0-9]+$/;\nconst appleMusicAlbumRegex = /^https?:\\/\\/music\\.apple\\.com\\/.+?\\/album\\/.+\\/([0-9]+)$/;\n// #endregion scary things above *sigh*\n\nclass QueryResolver {\n    /**\n     * Query resolver\n     */\n    private constructor() {} // eslint-disable-line @typescript-eslint/no-empty-function\n\n    static get regex() {\n        return {\n            spotifyAlbumRegex,\n            spotifyPlaylistRegex,\n            spotifySongRegex,\n            vimeoRegex,\n            reverbnationRegex,\n            attachmentRegex,\n            appleMusicAlbumRegex,\n            appleMusicPlaylistRegex,\n            appleMusicSongRegex\n        };\n    }\n\n    /**\n     * Resolves the given search query\n     * @param {string} query The query\n     * @returns {QueryType}\n     */\n    static resolve(query: string, fallbackSearchEngine: (typeof QueryType)[keyof typeof QueryType] = QueryType.AUTO_SEARCH): (typeof QueryType)[keyof typeof QueryType] {\n        query = !query.includes('youtube.com') ? query.trim() : query.replace(/(m(usic)?|gaming)\\./, '').trim();\n\n        // @ts-expect-error\n        if ((soundcloud.validateURL || soundcloud.default.validateURL)(query, 'track')) return QueryType.SOUNDCLOUD_TRACK;\n        // @ts-expect-error\n        if ((soundcloud.validateURL || soundcloud.default.validateURL)(query, 'playlist') || query.includes('/sets/')) return QueryType.SOUNDCLOUD_PLAYLIST;\n        if (YouTube.isPlaylist(query)) return QueryType.YOUTUBE_PLAYLIST;\n        if (QueryResolver.validateId(query) || QueryResolver.validateURL(query)) return QueryType.YOUTUBE_VIDEO;\n        if (spotifySongRegex.test(query)) return QueryType.SPOTIFY_SONG;\n        if (spotifyPlaylistRegex.test(query)) return QueryType.SPOTIFY_PLAYLIST;\n        if (spotifyAlbumRegex.test(query)) return QueryType.SPOTIFY_ALBUM;\n        if (vimeoRegex.test(query)) return QueryType.VIMEO;\n        if (reverbnationRegex.test(query)) return QueryType.REVERBNATION;\n        if (appleMusicAlbumRegex.test(query)) return QueryType.APPLE_MUSIC_ALBUM;\n        if (appleMusicPlaylistRegex.test(query)) return QueryType.APPLE_MUSIC_PLAYLIST;\n        if (appleMusicSongRegex.test(query)) return QueryType.APPLE_MUSIC_SONG;\n        if (attachmentRegex.test(query)) return QueryType.ARBITRARY;\n\n        return fallbackSearchEngine;\n    }\n\n    /**\n     * Parses vimeo id from url\n     * @param {string} query The query\n     * @returns {string}\n     */\n    static getVimeoID(query: string): string | null | undefined {\n        return QueryResolver.resolve(query) === QueryType.VIMEO\n            ? query\n                  .split('/')\n                  .filter((x) => !!x)\n                  .pop()\n            : null;\n    }\n\n    static validateId(q: string) {\n        return YouTube.Regex.VIDEO_ID.test(q);\n    }\n\n    static validateURL(q: string) {\n        return YouTube.Regex.VIDEO_URL.test(q);\n    }\n}\n\nexport { QueryResolver };\n","import { Snowflake, User, UserResolvable, VoiceState } from 'discord.js';\nimport { GuildQueue } from '../Structures';\nimport { Track } from '../Structures/Track';\nimport { Playlist } from '../Structures/Playlist';\nimport { downloadOptions } from 'ytdl-core';\nimport { QueryCache } from '../utils/QueryCache';\n\nexport type FiltersName = keyof QueueFilters;\n\nexport interface PlayerSearchResult {\n    playlist: Playlist | null;\n    tracks: Track[];\n}\n\n/**\n * @typedef {AudioFilters} QueueFilters\n */\nexport interface QueueFilters {\n    bassboost_low?: boolean;\n    bassboost?: boolean;\n    bassboost_high?: boolean;\n    '8D'?: boolean;\n    vaporwave?: boolean;\n    nightcore?: boolean;\n    phaser?: boolean;\n    tremolo?: boolean;\n    vibrato?: boolean;\n    reverse?: boolean;\n    treble?: boolean;\n    normalizer?: boolean;\n    normalizer2?: boolean;\n    surrounding?: boolean;\n    pulsator?: boolean;\n    subboost?: boolean;\n    karaoke?: boolean;\n    flanger?: boolean;\n    gate?: boolean;\n    haas?: boolean;\n    mcompand?: boolean;\n    mono?: boolean;\n    mstlr?: boolean;\n    mstrr?: boolean;\n    compressor?: boolean;\n    expander?: boolean;\n    softlimiter?: boolean;\n    chorus?: boolean;\n    chorus2d?: boolean;\n    chorus3d?: boolean;\n    fadein?: boolean;\n    dim?: boolean;\n    earrape?: boolean;\n    lofi?: boolean;\n}\n\n/**\n * The track source:\n * - soundcloud\n * - youtube\n * - spotify\n * - apple_music\n * - arbitrary\n * @typedef {string} TrackSource\n */\nexport type TrackSource = 'soundcloud' | 'youtube' | 'spotify' | 'apple_music' | 'arbitrary';\n\n/**\n * @typedef {object} RawTrackData\n * @property {string} title The title\n * @property {string} description The description\n * @property {string} author The author\n * @property {string} url The url\n * @property {string} thumbnail The thumbnail\n * @property {string} duration The duration\n * @property {number} views The views\n * @property {User} requestedBy The user who requested this track\n * @property {Playlist} [playlist] The playlist\n * @property {TrackSource} [source=\"arbitrary\"] The source\n * @property {any} [engine] The engine\n * @property {boolean} [live] If this track is live\n * @property {any} [raw] The raw data\n */\nexport interface RawTrackData {\n    title: string;\n    description: string;\n    author: string;\n    url: string;\n    thumbnail: string;\n    duration: string;\n    views: number;\n    requestedBy?: User | null;\n    playlist?: Playlist;\n    source?: TrackSource;\n    engine?: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n    live?: boolean;\n    raw?: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n    queryType?: SearchQueryType;\n}\n\n/**\n * @typedef {object} TimeData\n * @property {number} days Time in days\n * @property {number} hours Time in hours\n * @property {number} minutes Time in minutes\n * @property {number} seconds Time in seconds\n */\nexport interface TimeData {\n    days: number;\n    hours: number;\n    minutes: number;\n    seconds: number;\n}\n\n/**\n * @typedef {object} PlayerProgressbarOptions\n * @property {boolean} [timecodes] If it should render time codes\n * @property {boolean} [queue] If it should create progress bar for the whole queue\n * @property {number} [length] The bar length\n * @property {string} [line] The bar track\n * @property {string} [indicator] The indicator\n */\nexport interface PlayerProgressbarOptions {\n    timecodes?: boolean;\n    length?: number;\n    line?: string;\n    indicator?: string;\n    queue?: boolean;\n}\n\n/**\n * The search query type\n * This can be one of:\n * - AUTO\n * - YOUTUBE\n * - YOUTUBE_PLAYLIST\n * - SOUNDCLOUD_TRACK\n * - SOUNDCLOUD_PLAYLIST\n * - SOUNDCLOUD\n * - SPOTIFY_SONG\n * - SPOTIFY_ALBUM\n * - SPOTIFY_PLAYLIST\n * - SPOTIFY_SEARCH\n * - FACEBOOK\n * - VIMEO\n * - ARBITRARY\n * - REVERBNATION\n * - YOUTUBE_SEARCH\n * - YOUTUBE_VIDEO\n * - SOUNDCLOUD_SEARCH\n * - APPLE_MUSIC_SONG\n * - APPLE_MUSIC_ALBUM\n * - APPLE_MUSIC_PLAYLIST\n * - APPLE_MUSIC_SEARCH\n * - FILE\n * - AUTO_SEARCH\n * @typedef {string} QueryType\n */\nexport const QueryType = {\n    AUTO: 'auto',\n    YOUTUBE: 'youtube',\n    YOUTUBE_PLAYLIST: 'youtubePlaylist',\n    SOUNDCLOUD_TRACK: 'soundcloudTrack',\n    SOUNDCLOUD_PLAYLIST: 'soundcloudPlaylist',\n    SOUNDCLOUD: 'soundcloud',\n    SPOTIFY_SONG: 'spotifySong',\n    SPOTIFY_ALBUM: 'spotifyAlbum',\n    SPOTIFY_PLAYLIST: 'spotifyPlaylist',\n    SPOTIFY_SEARCH: 'spotifySearch',\n    FACEBOOK: 'facebook',\n    VIMEO: 'vimeo',\n    ARBITRARY: 'arbitrary',\n    REVERBNATION: 'reverbnation',\n    YOUTUBE_SEARCH: 'youtubeSearch',\n    YOUTUBE_VIDEO: 'youtubeVideo',\n    SOUNDCLOUD_SEARCH: 'soundcloudSearch',\n    APPLE_MUSIC_SONG: 'appleMusicSong',\n    APPLE_MUSIC_ALBUM: 'appleMusicAlbum',\n    APPLE_MUSIC_PLAYLIST: 'appleMusicPlaylist',\n    APPLE_MUSIC_SEARCH: 'appleMusicSearch',\n    FILE: 'file',\n    AUTO_SEARCH: 'autoSearch'\n} as const;\n\nexport type SearchQueryType = keyof typeof QueryType | (typeof QueryType)[keyof typeof QueryType];\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexport interface PlayerEvents {\n    debug: (message: string) => any;\n    error: (error: Error) => any;\n    voiceStateUpdate: (queue: GuildQueue, oldState: VoiceState, newState: VoiceState) => any;\n}\n\nexport enum PlayerEvent {\n    debug = 'debug',\n    error = 'error',\n    voiceStateUpdate = 'voiceStateUpdate'\n}\n\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\n/**\n * @typedef {object} PlayOptions\n * @property {boolean} [filtersUpdate=false] If this play was triggered for filters update\n * @property {string[]} [encoderArgs=[]] FFmpeg args passed to encoder\n * @property {number} [seek] Time to seek to before playing\n * @property {boolean} [immediate=false] If it should start playing the provided track immediately\n */\nexport interface PlayOptions {\n    filtersUpdate?: boolean;\n    encoderArgs?: string[];\n    seek?: number;\n    immediate?: boolean;\n}\n\nexport type QueryExtractorSearch = `ext:${string}`;\n\n/**\n * @typedef {object} SearchOptions\n * @property {UserResolvable} requestedBy The user who requested this search\n * @property {typeof QueryType|string} [searchEngine='auto'] The query search engine, can be extractor name to target specific one (custom)\n * @property {string[]} [blockExtractors[]] List of the extractors to block\n * @property {boolean} [ignoreCache] If it should ignore query cache lookup\n * @property {SearchQueryType} [fallbackSearchEngine='autoSearch'] Fallback search engine to use\n */\nexport interface SearchOptions {\n    requestedBy?: UserResolvable;\n    searchEngine?: SearchQueryType | QueryExtractorSearch;\n    blockExtractors?: string[];\n    ignoreCache?: boolean;\n    fallbackSearchEngine?: (typeof QueryType)[keyof typeof QueryType];\n}\n\n/**\n * The queue repeat mode. This can be one of:\n * - OFF\n * - TRACK\n * - QUEUE\n * - AUTOPLAY\n * @typedef {number} QueueRepeatMode\n */\nexport enum QueueRepeatMode {\n    OFF = 0,\n    TRACK = 1,\n    QUEUE = 2,\n    AUTOPLAY = 3\n}\n\n/**\n * @typedef {object} PlaylistInitData\n * @property {Track[]} tracks The tracks of this playlist\n * @property {string} title The playlist title\n * @property {string} description The description\n * @property {string} thumbnail The thumbnail\n * @property {album|playlist} type The playlist type: `album` | `playlist`\n * @property {TrackSource} source The playlist source\n * @property {object} author The playlist author\n * @property {string} [author.name] The author name\n * @property {string} [author.url] The author url\n * @property {string} id The playlist id\n * @property {string} url The playlist url\n * @property {any} [rawPlaylist] The raw playlist data\n */\nexport interface PlaylistInitData {\n    tracks: Track[];\n    title: string;\n    description: string;\n    thumbnail: string;\n    type: 'album' | 'playlist';\n    source: TrackSource;\n    author: {\n        name: string;\n        url: string;\n    };\n    id: string;\n    url: string;\n    rawPlaylist?: any; // eslint-disable-line @typescript-eslint/no-explicit-any\n}\n\n/**\n * @typedef {object} TrackJSON\n * @property {string} title The track title\n * @property {string} description The track description\n * @property {string} author The author\n * @property {string} url The url\n * @property {string} thumbnail The thumbnail\n * @property {string} duration The duration\n * @property {number} durationMS The duration in ms\n * @property {number} views The views count\n * @property {Snowflake} requestedBy The id of the user who requested this track\n * @property {PlaylistJSON} [playlist] The playlist info (if any)\n */\nexport interface TrackJSON {\n    id: Snowflake;\n    title: string;\n    description: string;\n    author: string;\n    url: string;\n    thumbnail: string;\n    duration: string;\n    durationMS: number;\n    views: number;\n    requestedBy: Snowflake;\n    playlist?: PlaylistJSON;\n}\n\n/**\n * @typedef {object} PlaylistJSON\n * @property {string} id The playlist id\n * @property {string} url The playlist url\n * @property {string} title The playlist title\n * @property {string} description The playlist description\n * @property {string} thumbnail The thumbnail\n * @property {album|playlist} type The playlist type: `album` | `playlist`\n * @property {TrackSource} source The track source\n * @property {object} author The playlist author\n * @property {string} [author.name] The author name\n * @property {string} [author.url] The author url\n * @property {TrackJSON[]} tracks The tracks data (if any)\n */\nexport interface PlaylistJSON {\n    id: string;\n    url: string;\n    title: string;\n    description: string;\n    thumbnail: string;\n    type: 'album' | 'playlist';\n    source: TrackSource;\n    author: {\n        name: string;\n        url: string;\n    };\n    tracks: TrackJSON[];\n}\n\n/**\n * @typedef {object} PlayerInitOptions\n * @property {boolean} [autoRegisterExtractor=true] If it should automatically register `@discord-player/extractor`\n * @property {YTDLDownloadOptions} [ytdlOptions] The options passed to `ytdl-core`\n * @property {number} [connectionTimeout=20000] The voice connection timeout\n * @property {boolean} [smoothVolume=true] Toggle smooth volume transition\n * @property {boolean} [lagMonitor=30000] Time in ms to re-monitor event loop lag\n * @property {boolean} [lockVoiceStateHandler] Prevent voice state handler from being overridden\n * @property {string[]} [blockExtractors] List of extractors to disable querying metadata from\n * @property {string[]} [blockStreamFrom] List of extractors to disable streaming from\n * @property {QueryCache | null} [queryCache] Query cache provider\n * @property {boolean} [ignoreInstance] Ignore player instance\n */\nexport interface PlayerInitOptions {\n    autoRegisterExtractor?: boolean;\n    ytdlOptions?: downloadOptions;\n    connectionTimeout?: number;\n    smoothVolume?: boolean;\n    lagMonitor?: number;\n    lockVoiceStateHandler?: boolean;\n    blockExtractors?: string[];\n    blockStreamFrom?: string[];\n    queryCache?: QueryCache | null;\n    ignoreInstance?: boolean;\n}\n","import { User, escapeMarkdown, SnowflakeUtil } from 'discord.js';\nimport { Player } from '../Player';\nimport { RawTrackData, SearchQueryType, TrackJSON } from '../types/types';\nimport { Playlist } from './Playlist';\nimport { GuildQueue } from './GuildQueue';\nimport { BaseExtractor } from '../extractors/BaseExtractor';\n\nexport type TrackResolvable = Track | string | number;\n\nexport class Track {\n    public player!: Player;\n    public title!: string;\n    public description!: string;\n    public author!: string;\n    public url!: string;\n    public thumbnail!: string;\n    public duration!: string;\n    public views!: number;\n    public requestedBy: User | null = null;\n    public playlist?: Playlist;\n    public queryType: SearchQueryType | null | undefined = null;\n    public raw: RawTrackData = {\n        source: 'arbitrary'\n    } as RawTrackData;\n    public extractor: BaseExtractor | null = null;\n    public readonly id = SnowflakeUtil.generate().toString();\n\n    /**\n     * Track constructor\n     * @param {Player} player The player that instantiated this Track\n     * @param {RawTrackData} data Track data\n     */\n    constructor(player: Player, data: RawTrackData) {\n        /**\n         * The player that instantiated this Track\n         * @name Track#player\n         * @type {Player}\n         * @readonly\n         */\n        Object.defineProperty(this, 'player', { value: player, enumerable: false });\n\n        /**\n         * Title of this track\n         * @name Track#title\n         * @type {string}\n         */\n\n        /**\n         * Description of this track\n         * @name Track#description\n         * @type {string}\n         */\n\n        /**\n         * Author of this track\n         * @name Track#author\n         * @type {string}\n         */\n\n        /**\n         * URL of this track\n         * @name Track#url\n         * @type {string}\n         */\n\n        /**\n         * Thumbnail of this track\n         * @name Track#thumbnail\n         * @type {string}\n         */\n\n        /**\n         * Duration of this track\n         * @name Track#duration\n         * @type {string}\n         */\n\n        /**\n         * Views count of this track\n         * @name Track#views\n         * @type {number}\n         */\n\n        /**\n         * Person who requested this track\n         * @name Track#requestedBy\n         * @type {User}\n         */\n\n        /**\n         * If this track belongs to playlist\n         * @name Track#fromPlaylist\n         * @type {boolean}\n         */\n\n        /**\n         * Raw track data\n         * @name Track#raw\n         * @type {RawTrackData}\n         */\n\n        /**\n         * The track id\n         * @name Track#id\n         * @type {Snowflake}\n         * @readonly\n         */\n\n        /**\n         * The playlist which track belongs\n         * @name Track#playlist\n         * @type {Playlist}\n         */\n\n        void this._patch(data);\n    }\n\n    private _patch(data: RawTrackData) {\n        this.title = escapeMarkdown(data.title ?? '');\n        this.author = data.author ?? '';\n        this.url = data.url ?? '';\n        this.thumbnail = data.thumbnail ?? '';\n        this.duration = data.duration ?? '';\n        this.views = data.views ?? 0;\n        this.queryType = data.queryType;\n        this.requestedBy = data.requestedBy || null;\n        this.playlist = data.playlist;\n        this.raw = Object.assign({}, { source: data.raw?.source ?? data.source }, data.raw ?? data);\n    }\n\n    /**\n     * The queue in which this track is located\n     * @type {Queue}\n     */\n    get queue(): GuildQueue {\n        return this.player.nodes.cache.find((q) => q.tracks.some((ab) => ab.id === this.id))!;\n    }\n\n    /**\n     * The track duration in millisecond\n     * @type {number}\n     */\n    get durationMS(): number {\n        const times = (n: number, t: number) => {\n            let tn = 1;\n            for (let i = 0; i < t; i++) tn *= n;\n            return t <= 0 ? 1000 : tn * 1000;\n        };\n\n        return this.duration\n            .split(':')\n            .reverse()\n            .map((m, i) => parseInt(m) * times(60, i))\n            .reduce((a, c) => a + c, 0);\n    }\n\n    /**\n     * Returns source of this track\n     * @type {TrackSource}\n     */\n    get source() {\n        return this.raw?.source ?? 'arbitrary';\n    }\n\n    /**\n     * String representation of this track\n     * @returns {string}\n     */\n    toString(): string {\n        return `${this.title} by ${this.author}`;\n    }\n\n    /**\n     * Raw JSON representation of this track\n     * @returns {TrackJSON}\n     */\n    toJSON(hidePlaylist?: boolean) {\n        return {\n            id: this.id,\n            title: this.title,\n            description: this.description,\n            author: this.author,\n            url: this.url,\n            thumbnail: this.thumbnail,\n            duration: this.duration,\n            durationMS: this.durationMS,\n            views: this.views,\n            requestedBy: this.requestedBy?.id || null,\n            playlist: hidePlaylist ? null : this.playlist?.toJSON() ?? null\n        } as TrackJSON;\n    }\n}\n","import { Readable } from 'stream';\nimport { FiltersName, QueueFilters } from '../types/types';\nimport AudioFilters from '../utils/AudioFilters';\nimport { GuildQueue } from './GuildQueue';\nimport { BiquadFilters, Equalizer, EqualizerBand, PCMFilters } from '@discord-player/equalizer';\nimport { FFmpegStreamOptions, createFFmpegStream } from '../utils/FFmpegStream';\n\ntype Filters = keyof typeof AudioFilters.filters;\n\nconst makeBands = (arr: number[]) => {\n    return Array.from(\n        {\n            length: Equalizer.BAND_COUNT\n        },\n        (_, i) => ({\n            band: i,\n            gain: arr[i] ? arr[i] / 30 : 0\n        })\n    ) as EqualizerBand[];\n};\n\nexport const EqualizerConfigurationPreset = {\n    Flat: makeBands([]),\n    Classical: makeBands([-1.11022e-15, -1.11022e-15, -1.11022e-15, -1.11022e-15, -1.11022e-15, -1.11022e-15, -7.2, -7.2, -7.2, -9.6]),\n    Club: makeBands([-1.11022e-15, -1.11022e-15, 8.0, 5.6, 5.6, 5.6, 3.2, -1.11022e-15, -1.11022e-15, -1.11022e-15]),\n    Dance: makeBands([9.6, 7.2, 2.4, -1.11022e-15, -1.11022e-15, -5.6, -7.2, -7.2, -1.11022e-15, -1.11022e-15]),\n    FullBass: makeBands([-8.0, 9.6, 9.6, 5.6, 1.6, -4.0, -8.0, -10.4, -11.2, -11.2]),\n    FullBassTreble: makeBands([7.2, 5.6, -1.11022e-15, -7.2, -4.8, 1.6, 8.0, 11.2, 12.0, 12.0]),\n    FullTreble: makeBands([-9.6, -9.6, -9.6, -4.0, 2.4, 11.2, 16.0, 16.0, 16.0, 16.8]),\n    Headphones: makeBands([4.8, 11.2, 5.6, -3.2, -2.4, 1.6, 4.8, 9.6, 12.8, 14.4]),\n    LargeHall: makeBands([10.4, 10.4, 5.6, 5.6, -1.11022e-15, -4.8, -4.8, -4.8, -1.11022e-15, -1.11022e-15]),\n    Live: makeBands([-4.8, -1.11022e-15, 4.0, 5.6, 5.6, 5.6, 4.0, 2.4, 2.4, 2.4]),\n    Party: makeBands([7.2, 7.2, -1.11022e-15, -1.11022e-15, -1.11022e-15, -1.11022e-15, -1.11022e-15, -1.11022e-15, 7.2, 7.2]),\n    Pop: makeBands([-1.6, 4.8, 7.2, 8.0, 5.6, -1.11022e-15, -2.4, -2.4, -1.6, -1.6]),\n    Reggae: makeBands([-1.11022e-15, -1.11022e-15, -1.11022e-15, -5.6, -1.11022e-15, 6.4, 6.4, -1.11022e-15, -1.11022e-15, -1.11022e-15]),\n    Rock: makeBands([8.0, 4.8, -5.6, -8.0, -3.2, 4.0, 8.8, 11.2, 11.2, 11.2]),\n    Ska: makeBands([-2.4, -4.8, -4.0, -1.11022e-15, 4.0, 5.6, 8.8, 9.6, 11.2, 9.6]),\n    Soft: makeBands([4.8, 1.6, -1.11022e-15, -2.4, -1.11022e-15, 4.0, 8.0, 9.6, 11.2, 12.0]),\n    SoftRock: makeBands([4.0, 4.0, 2.4, -1.11022e-15, -4.0, -5.6, -3.2, -1.11022e-15, 2.4, 8.8]),\n    Techno: makeBands([8.0, 5.6, -1.11022e-15, -5.6, -4.8, -1.11022e-15, 8.0, 9.6, 9.6, 8.8])\n} as const;\n\nexport class FFmpegFilterer<Meta = unknown> {\n    #ffmpegFilters: Filters[] = [];\n    public constructor(public af: GuildQueueAudioFilters<Meta>) {}\n\n    #setFilters(filters: Filters[]) {\n        const ignoreFilters = this.filters.some((ff) => ff === 'nightcore' || ff === 'vaporwave') && !filters.some((ff) => ff === 'nightcore' || ff === 'vaporwave');\n        const seekTime = this.af.queue.node.getTimestamp(ignoreFilters)?.current.value || 0;\n        this.#ffmpegFilters = [...new Set(filters)];\n        return this.af.triggerReplay(seekTime);\n    }\n\n    /**\n     * Create ffmpeg stream\n     * @param source The stream source\n     * @param options The stream options\n     */\n    public createStream(source: string | Readable, options: FFmpegStreamOptions) {\n        return createFFmpegStream(source, options);\n    }\n\n    /**\n     * Set ffmpeg filters\n     * @param filters The filters\n     */\n    public setFilters(filters: Filters[] | Record<Filters, boolean> | boolean) {\n        let _filters: Filters[] = [];\n        if (typeof filters === 'boolean') {\n            _filters = !filters ? [] : (Object.keys(AudioFilters.filters) as Filters[]);\n        } else if (Array.isArray(filters)) {\n            _filters = filters;\n        } else {\n            _filters = Object.entries(filters)\n                .filter((res) => res[1] === true)\n                .map((m) => m[0]) as Filters[];\n        }\n\n        return this.#setFilters(_filters);\n    }\n\n    /**\n     * Currently active ffmpeg filters\n     */\n    public get filters() {\n        return this.#ffmpegFilters;\n    }\n\n    public set filters(filters: Filters[]) {\n        this.setFilters(filters);\n    }\n\n    /**\n     * Toggle given ffmpeg filter(s)\n     * @param filters The filter(s)\n     */\n    public toggle(filters: Filters[] | Filters) {\n        if (!Array.isArray(filters)) filters = [filters];\n        const fresh: Filters[] = [];\n\n        filters.forEach((f) => {\n            if (this.filters.includes(f)) return;\n            fresh.push(f);\n        });\n\n        return this.#setFilters(this.#ffmpegFilters.filter((r) => !filters.includes(r)).concat(fresh));\n    }\n\n    /**\n     * Set default filters\n     * @param ff Filters list\n     */\n    public setDefaults(ff: Filters[]) {\n        this.#ffmpegFilters = ff;\n    }\n\n    /**\n     * Get list of enabled filters\n     */\n    public getFiltersEnabled() {\n        return this.#ffmpegFilters;\n    }\n\n    /**\n     * Get list of disabled filters\n     */\n    public getFiltersDisabled() {\n        return AudioFilters.names.filter((f) => !this.#ffmpegFilters.includes(f));\n    }\n\n    /**\n     * Check if the given filter is enabled\n     * @param filter The filter\n     */\n    public isEnabled<T extends Filters>(filter: T): boolean {\n        return this.#ffmpegFilters.includes(filter);\n    }\n\n    /**\n     * Check if the given filter is disabled\n     * @param filter The filter\n     */\n    public isDisabled<T extends Filters>(filter: T): boolean {\n        return !this.isEnabled(filter);\n    }\n\n    /**\n     * Check if the given filter is a valid filter\n     * @param filter The filter to test\n     */\n    public isValidFilter(filter: string): filter is FiltersName {\n        return AudioFilters.has(filter as Filters);\n    }\n\n    /**\n     * Convert current filters to array\n     */\n    public toArray() {\n        return this.filters.map((filter) => AudioFilters.get(filter));\n    }\n\n    /**\n     * Convert current filters to JSON object\n     */\n    public toJSON() {\n        const obj = {} as Record<keyof QueueFilters, string>;\n\n        this.filters.forEach((filter) => (obj[filter] = AudioFilters.get(filter)));\n\n        return obj;\n    }\n\n    /**\n     * String representation of current filters\n     */\n    public toString() {\n        return AudioFilters.create(this.filters);\n    }\n}\n\nexport interface GuildQueueAFiltersCache {\n    equalizer: EqualizerBand[];\n    biquad: BiquadFilters | null;\n    filters: PCMFilters[];\n    volume: number;\n    sampleRate: number;\n}\n\nexport class GuildQueueAudioFilters<Meta = unknown> {\n    public graph = new AFilterGraph<Meta>(this);\n    public ffmpeg = new FFmpegFilterer<Meta>(this);\n    public equalizerPresets = EqualizerConfigurationPreset;\n    public _lastFiltersCache: GuildQueueAFiltersCache = {\n        biquad: null,\n        equalizer: [],\n        filters: [],\n        volume: 100,\n        sampleRate: -1\n    };\n    public constructor(public queue: GuildQueue<Meta>) {\n        if (typeof this.queue.options.volume === 'number') {\n            this._lastFiltersCache.volume = this.queue.options.volume;\n        }\n    }\n\n    /**\n     * Volume transformer\n     */\n    public get volume() {\n        return this.queue.dispatcher?.dsp?.volume || null;\n    }\n\n    /**\n     * 15 Band Equalizer\n     */\n    public get equalizer() {\n        return this.queue.dispatcher?.equalizer || null;\n    }\n\n    /**\n     * Digital biquad filters\n     */\n    public get biquad() {\n        return this.queue.dispatcher?.biquad || null;\n    }\n\n    /**\n     * DSP filters\n     */\n    public get filters() {\n        return this.queue.dispatcher?.filters || null;\n    }\n\n    /**\n     * Audio resampler\n     */\n    public get resampler() {\n        return this.queue.dispatcher?.resampler || null;\n    }\n\n    /**\n     * Replay current track in transition mode\n     * @param seek The duration to seek to\n     */\n    public async triggerReplay(seek = 0) {\n        if (!this.queue.currentTrack) return false;\n        try {\n            await this.queue.node.play(this.queue.currentTrack, {\n                queue: false,\n                seek,\n                transitionMode: true\n            });\n\n            return true;\n        } catch {\n            return false;\n        }\n    }\n}\n\nexport class AFilterGraph<Meta = unknown> {\n    public constructor(public af: GuildQueueAudioFilters<Meta>) {}\n\n    public get ffmpeg() {\n        return this.af.ffmpeg.filters;\n    }\n\n    public get equalizer() {\n        return (this.af.equalizer?.bandMultipliers || []).map((m, i) => ({\n            band: i,\n            gain: m\n        })) as EqualizerBand[];\n    }\n\n    public get biquad() {\n        return null;\n        // return (this.af.biquad?.getFilterName() as Exclude<BiquadFilters, number> | null) || null;\n    }\n\n    public get filters() {\n        return this.af.filters?.filters || [];\n    }\n\n    public get volume() {\n        return this.af.volume;\n    }\n\n    public get resampler() {\n        return this.af.resampler;\n    }\n\n    public dump(): FilterGraph {\n        return {\n            ffmpeg: this.ffmpeg,\n            equalizer: this.equalizer,\n            biquad: this.biquad,\n            filters: this.filters,\n            sampleRate: this.resampler?.targetSampleRate || this.resampler?.sampleRate || 48000,\n            volume: this.volume?.volume ?? 100\n        };\n    }\n}\n\nexport interface FilterGraph {\n    ffmpeg: Filters[];\n    equalizer: EqualizerBand[];\n    biquad: Exclude<BiquadFilters, number> | null;\n    filters: PCMFilters[];\n    volume: number;\n    sampleRate: number;\n}\n","import * as prism from 'prism-media';\nimport type { Duplex, Readable } from 'stream';\n\nexport interface FFmpegStreamOptions {\n    fmt?: string;\n    encoderArgs?: string[];\n    seek?: number;\n    skip?: boolean;\n    cookies?: string;\n}\n\nexport function FFMPEG_ARGS_STRING(stream: string, fmt?: string, cookies?: string) {\n    // prettier-ignore\n    const args = [\n        \"-reconnect\", \"1\",\n        \"-reconnect_streamed\", \"1\",\n        \"-reconnect_delay_max\", \"5\",\n        \"-i\", stream,\n        \"-analyzeduration\", \"0\",\n        \"-loglevel\", \"0\",\n        \"-f\", `${typeof fmt === \"string\" ? fmt : \"s16le\"}`,\n        \"-ar\", \"48000\",\n        \"-ac\", \"2\"\n    ];\n\n    if (typeof cookies === 'string') {\n        // https://ffmpeg.org/ffmpeg-protocols.html#HTTP-Cookies\n        args.push('-cookies', cookies.startsWith('\"') ? cookies : `\"${cookies}\"`);\n    }\n\n    return args;\n}\n\nexport function FFMPEG_ARGS_PIPED(fmt?: string) {\n    // prettier-ignore\n    return [\n        \"-analyzeduration\", \"0\",\n        \"-loglevel\", \"0\",\n        \"-f\", `${typeof fmt === \"string\" ? fmt : \"s16le\"}`,\n        \"-ar\", \"48000\",\n        \"-ac\", \"2\"\n    ];\n}\n\n/**\n * Creates FFmpeg stream\n * @param stream The source stream\n * @param options FFmpeg stream options\n */\nexport function createFFmpegStream(stream: Readable | Duplex | string, options?: FFmpegStreamOptions) {\n    if (options?.skip && typeof stream !== 'string') return stream;\n    options ??= {};\n    const args = typeof stream === 'string' ? FFMPEG_ARGS_STRING(stream, options.fmt, options.cookies) : FFMPEG_ARGS_PIPED(options.fmt);\n\n    if (!Number.isNaN(options.seek)) args.unshift('-ss', String(options.seek));\n    if (Array.isArray(options.encoderArgs)) args.push(...options.encoderArgs);\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const transcoder = new (prism.FFmpeg || (<any>prism).default.FFmpeg)({ shell: false, args });\n    transcoder.on('close', () => transcoder.destroy());\n\n    if (typeof stream !== 'string') {\n        stream.on('error', () => transcoder.destroy());\n        stream.pipe(transcoder);\n    }\n\n    return transcoder;\n}\n","import { GuildQueue } from './GuildQueue';\n\nexport interface GuildQueueStatisticsMetadata {\n    latency: {\n        eventLoop: number;\n        voiceConnection: number;\n    };\n    status: {\n        buffering: boolean;\n        playing: boolean;\n        paused: boolean;\n        idle: boolean;\n    };\n    tracksCount: number;\n    historySize: number;\n    extractors: number;\n    listeners: number;\n    memoryUsage: NodeJS.MemoryUsage;\n    versions: {\n        node: string;\n        player: string;\n    };\n}\n\nexport class GuildQueueStatistics<Meta = unknown> {\n    public constructor(public queue: GuildQueue<Meta>) {}\n\n    /**\n     * Generate statistics of this queue\n     */\n    public generate() {\n        return {\n            latency: {\n                eventLoop: this.queue.player.eventLoopLag,\n                voiceConnection: this.queue.ping\n            },\n            status: {\n                buffering: this.queue.node.isBuffering(),\n                playing: this.queue.node.isPlaying(),\n                paused: this.queue.node.isPaused(),\n                idle: this.queue.node.isIdle()\n            },\n            tracksCount: this.queue.tracks.size,\n            historySize: this.queue.history.tracks.size,\n            extractors: this.queue.player.extractors.size,\n            listeners: this.queue.guild.members.me?.voice.channel?.members.filter((m) => !m.user.bot).size || 0,\n            memoryUsage: process.memoryUsage(),\n            versions: {\n                node: process.version,\n                player: '6.1.1'\n            }\n        } as GuildQueueStatisticsMetadata;\n    }\n}\n","export class TypeUtil {\n    private constructor() {\n        return TypeUtil;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    public static isFunction(t: unknown): t is Function {\n        return typeof t === 'function';\n    }\n\n    public static isNumber(t: unknown): t is number {\n        return typeof t === 'number' && !isNaN(t);\n    }\n\n    public static isString(t: unknown): t is string {\n        return typeof t === 'string';\n    }\n\n    public static isBoolean(t: unknown): t is boolean {\n        return typeof t === 'boolean';\n    }\n\n    public static isNullish(t: unknown): t is null | undefined {\n        return t == null;\n    }\n\n    public static isArray(t: unknown): t is unknown[] {\n        return Array.isArray(t);\n    }\n}\n","import type { Player } from '../../Player';\nimport { Collection } from '@discord-player/utils';\n\nexport const instances = new Collection<string, Player>();\nexport const globalRegistry = new Collection<string, unknown>();\n","import { Player } from '../../Player';\nimport { instances } from './_container';\n\nexport function addPlayer(player: Player) {\n    if (instances.has(player.id)) return true;\n\n    instances.set(player.id, player);\n\n    return instances.has(player.id);\n}\n","import { Player } from '../../Player';\nimport { instances } from './_container';\n\nexport function clearPlayer(player: Player) {\n    return instances.delete(player.id);\n}\n","import { instances } from './_container';\n\nexport function getPlayers() {\n    return instances.array();\n}\n","import { globalRegistry } from './_container';\n\nexport function getGlobalRegistry() {\n    return globalRegistry;\n}\n","import { UserResolvable } from 'discord.js';\nimport { PassThrough, type Readable } from 'stream';\nimport { EndBehaviorType } from '@discordjs/voice';\nimport * as prism from 'prism-media';\nimport { StreamDispatcher } from '../VoiceInterface/StreamDispatcher';\nimport { Track } from './Track';\nimport { RawTrackData } from '../types/types';\n\nexport interface VoiceReceiverOptions {\n    mode?: 'opus' | 'pcm';\n    end?: EndBehaviorType;\n    silenceDuration?: number;\n    crc?: boolean;\n}\n\nexport type RawTrackInit = Partial<Omit<RawTrackData, 'author' | 'playlist' | 'source' | 'engine' | 'raw' | 'queryType' | 'description' | 'views'>>;\n\nexport class VoiceReceiverNode {\n    public constructor(public dispatcher: StreamDispatcher) {}\n\n    public createRawTrack(stream: Readable, data: RawTrackInit = {}) {\n        data.title ??= `Recording ${Date.now()}`;\n\n        return new Track(this.dispatcher.queue.player, {\n            author: 'Discord',\n            description: data.title,\n            title: data.title,\n            duration: data.duration || '0:00',\n            views: 0,\n            requestedBy: data.requestedBy,\n            thumbnail: data.thumbnail || 'https://cdn.discordapp.com/embed/avatars/0.png',\n            url: data.url || 'https://discord.com',\n            source: 'arbitrary',\n            raw: {\n                engine: stream,\n                source: 'arbitrary'\n            }\n        });\n    }\n\n    /**\n     * Merge multiple streams together\n     * @param streams The array of streams to merge\n     */\n    public mergeRecordings(streams: Readable[]) {\n        // TODO\n        void streams;\n        throw new Error('Not implemented');\n    }\n\n    /**\n     * Record a user in voice channel\n     * @param user The user to record\n     * @param options Recording options\n     */\n    public recordUser(\n        user: UserResolvable,\n        options: VoiceReceiverOptions = {\n            end: EndBehaviorType.AfterSilence,\n            mode: 'pcm',\n            silenceDuration: 1000\n        }\n    ) {\n        const _user = this.dispatcher.queue.player.client.users.resolveId(user);\n\n        const passThrough = new PassThrough();\n        const receiver = this.dispatcher.voiceConnection.receiver;\n\n        if (!receiver) throw new Error('Voice receiver is not available, maybe connect to a voice channel first?');\n\n        receiver.speaking.on('start', (userId) => {\n            if (userId === _user) {\n                const receiveStream = receiver.subscribe(_user, {\n                    end: {\n                        behavior: options.end || EndBehaviorType.AfterSilence,\n                        duration: options.silenceDuration ?? 1000\n                    }\n                });\n\n                setImmediate(async () => {\n                    if (options.mode === 'pcm') {\n                        const pcm = receiveStream.pipe(\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            new (prism.opus || (<any>prism).default.opus).Decoder({\n                                channels: 2,\n                                frameSize: 960,\n                                rate: 48000\n                            })\n                        );\n                        return pcm.pipe(passThrough);\n                    } else {\n                        return receiveStream.pipe(passThrough);\n                    }\n                }).unref();\n            }\n        });\n\n        return passThrough as Readable;\n    }\n}\n","import { User } from 'discord.js';\nimport { BaseExtractor } from '../extractors/BaseExtractor';\nimport { Player } from '../Player';\nimport { QueryExtractorSearch, QueryType, SearchQueryType } from '../types/types';\nimport { Playlist } from './Playlist';\nimport { Track } from './Track';\n\nexport interface SearchResultData {\n    query: string;\n    queryType?: SearchQueryType | QueryExtractorSearch | null;\n    extractor?: BaseExtractor | null;\n    playlist?: Playlist | null;\n    tracks?: Track[];\n    requestedBy?: User | null;\n}\n\nexport class SearchResult {\n    public constructor(public player: Player, private _data: SearchResultData) {\n        this._data.tracks?.forEach((track) => {\n            track.extractor ??= this._data.extractor || null;\n            track.requestedBy ??= _data.requestedBy || null;\n        });\n    }\n\n    public setQueryType(type: SearchQueryType | QueryExtractorSearch) {\n        this._data.queryType = type;\n        return this;\n    }\n\n    public setRequestedBy(user: User) {\n        this._data.requestedBy = user;\n        this._data.tracks?.forEach((track) => {\n            track.requestedBy = user;\n        });\n        return this;\n    }\n\n    public setExtractor(extractor: BaseExtractor) {\n        this._data.extractor = extractor;\n        this._data.tracks?.forEach((track) => {\n            track.extractor = extractor;\n        });\n        return this;\n    }\n\n    public setTracks(tracks: Track[]) {\n        this._data.tracks = tracks;\n        return this;\n    }\n\n    public setQuery(query: string) {\n        this._data.query = query;\n        return this;\n    }\n\n    public setPlaylist(playlist: Playlist) {\n        this._data.playlist = playlist;\n        return this;\n    }\n\n    /**\n     * The search query\n     */\n    public get query() {\n        return this._data.query;\n    }\n\n    /**\n     * The search query type\n     */\n    public get queryType() {\n        return this._data.queryType || QueryType.AUTO;\n    }\n\n    /**\n     * The extractor\n     */\n    public get extractor() {\n        return this._data.extractor || null;\n    }\n\n    /**\n     * Playlist result\n     */\n    public get playlist() {\n        return this._data.playlist;\n    }\n\n    /**\n     * Tracks result\n     */\n    public get tracks() {\n        return this._data.tracks || [];\n    }\n\n    /**\n     * Requested by\n     */\n    public get requestedBy() {\n        return this._data.requestedBy || null;\n    }\n\n    /**\n     * Re-execute this search\n     */\n    public async execute() {\n        return this.player.search(this.query, {\n            searchEngine: this.queryType,\n            requestedBy: this.requestedBy!\n        });\n    }\n\n    /**\n     * If this search result is empty\n     */\n    public isEmpty() {\n        return !this.tracks.length;\n    }\n\n    /**\n     * If this search result has playlist\n     */\n    public hasPlaylist() {\n        return this.playlist != null;\n    }\n\n    /**\n     * If this search result has tracks\n     */\n    public hasTracks() {\n        return this.tracks.length > 0;\n    }\n\n    /**\n     * JSON representation of this search\n     */\n    public toJSON() {\n        return {\n            query: this.query,\n            queryType: this.queryType,\n            playlist: this.playlist?.toJSON(false) || null,\n            tracks: this.tracks.map((m) => m.toJSON(true)),\n            extractor: this.extractor?.identifier || null,\n            requestedBy: this.requestedBy?.toJSON() || null\n        };\n    }\n}\n","export enum ErrorStatusCode {\n    STREAM_ERROR = 'StreamError',\n    AUDIO_PLAYER_ERROR = 'AudioPlayerError',\n    PLAYER_ERROR = 'PlayerError',\n    NO_AUDIO_RESOURCE = 'NoAudioResource',\n    UNKNOWN_GUILD = 'UnknownGuild',\n    INVALID_ARG_TYPE = 'InvalidArgType',\n    UNKNOWN_EXTRACTOR = 'UnknownExtractor',\n    INVALID_EXTRACTOR = 'InvalidExtractor',\n    INVALID_CHANNEL_TYPE = 'InvalidChannelType',\n    INVALID_TRACK = 'InvalidTrack',\n    UNKNOWN_REPEAT_MODE = 'UnknownRepeatMode',\n    TRACK_NOT_FOUND = 'TrackNotFound',\n    NO_CONNECTION = 'NoConnection',\n    DESTROYED_QUEUE = 'DestroyedQueue'\n}\n\nexport class PlayerError extends Error {\n    message: string;\n    statusCode: ErrorStatusCode;\n    createdAt = new Date();\n\n    constructor(message: string, code: ErrorStatusCode = ErrorStatusCode.PLAYER_ERROR) {\n        super();\n\n        this.message = `[${code}] ${message}`;\n        this.statusCode = code;\n        this.name = code;\n\n        Error.captureStackTrace(this);\n    }\n\n    get createdTimestamp() {\n        return this.createdAt.getTime();\n    }\n\n    valueOf() {\n        return this.statusCode;\n    }\n\n    toJSON() {\n        return {\n            stack: this.stack,\n            code: this.statusCode,\n            message: this.message,\n            created: this.createdTimestamp\n        };\n    }\n\n    toString() {\n        return this.stack;\n    }\n}\n","import { VoiceChannel, StageChannel, Snowflake } from 'discord.js';\nimport { DiscordGatewayAdapterCreator, joinVoiceChannel, VoiceConnection, getVoiceConnection, VoiceConnectionStatus } from '@discordjs/voice';\nimport { StreamDispatcher } from './StreamDispatcher';\nimport { Collection } from '@discord-player/utils';\nimport { GuildQueue } from '../Structures';\nimport type { Player } from '../Player';\n\nclass VoiceUtils {\n    public cache: Collection<Snowflake, StreamDispatcher>;\n\n    /**\n     * The voice utils\n     * @private\n     */\n    constructor(public player: Player) {\n        /**\n         * The cache where voice utils stores stream managers\n         * @type {Collection<Snowflake, StreamDispatcher>}\n         */\n        this.cache = new Collection<Snowflake, StreamDispatcher>();\n    }\n\n    /**\n     * Joins a voice channel, creating basic stream dispatch manager\n     * @param {StageChannel|VoiceChannel} channel The voice channel\n     * @param {object} [options] Join options\n     * @returns {Promise<StreamDispatcher>}\n     */\n    public async connect(\n        channel: VoiceChannel | StageChannel,\n        options?: {\n            deaf?: boolean;\n            maxTime?: number;\n            queue: GuildQueue;\n        }\n    ): Promise<StreamDispatcher> {\n        if (!options?.queue) throw new Error('GuildQueue is required');\n        const conn = await this.join(channel, options);\n        const sub = new StreamDispatcher(conn, channel, options.queue, options.maxTime);\n        this.cache.set(channel.guild.id, sub);\n        return sub;\n    }\n\n    /**\n     * Joins a voice channel\n     * @param {StageChannel|VoiceChannel} [channel] The voice/stage channel to join\n     * @param {object} [options] Join options\n     * @returns {VoiceConnection}\n     */\n    public async join(\n        channel: VoiceChannel | StageChannel,\n        options?: {\n            deaf?: boolean;\n            maxTime?: number;\n        }\n    ) {\n        const conn = joinVoiceChannel({\n            guildId: channel.guild.id,\n            channelId: channel.id,\n            adapterCreator: channel.guild.voiceAdapterCreator as unknown as DiscordGatewayAdapterCreator,\n            selfDeaf: Boolean(options?.deaf),\n            debug: this.player.events.eventNames().includes('debug')\n        });\n\n        return conn;\n    }\n\n    /**\n     * Disconnects voice connection\n     * @param {VoiceConnection} connection The voice connection\n     * @returns {void}\n     */\n    public disconnect(connection: VoiceConnection | StreamDispatcher) {\n        if (connection instanceof StreamDispatcher) connection = connection.voiceConnection;\n\n        try {\n            if (connection.state.status !== VoiceConnectionStatus.Destroyed) return connection.destroy();\n        } catch {\n            //\n        }\n    }\n\n    /**\n     * Returns Discord Player voice connection\n     * @param {Snowflake} guild The guild id\n     * @returns {StreamDispatcher}\n     */\n    public getConnection(guild: Snowflake) {\n        return this.cache.get(guild) || getVoiceConnection(guild);\n    }\n}\n\nexport { VoiceUtils };\n","import {\n    AudioPlayer,\n    AudioPlayerError,\n    AudioPlayerStatus,\n    AudioResource,\n    createAudioPlayer,\n    createAudioResource,\n    entersState,\n    StreamType,\n    VoiceConnection,\n    VoiceConnectionStatus,\n    VoiceConnectionDisconnectReason,\n    version\n} from '@discordjs/voice';\nimport { StageChannel, VoiceChannel } from 'discord.js';\nimport type { Readable } from 'stream';\nimport { EventEmitter } from '@discord-player/utils';\nimport { Track } from '../Structures/Track';\nimport { Util } from '../utils/Util';\nimport { PlayerError, ErrorStatusCode } from '../Structures/PlayerError';\nimport { EqualizerBand, BiquadFilters, PCMFilters, FiltersChain } from '@discord-player/equalizer';\nimport { GuildQueue, PostProcessedResult } from '../Structures';\nimport { VoiceReceiverNode } from '../Structures/VoiceReceiverNode';\n\nconst needsKeepAlivePatch = (() => {\n    if ('DP_NO_KEEPALIVE_PATCH' in process.env) return false;\n    // we dont care about dev version and semver:major >= 1\n    if (version.includes('-dev') || version.startsWith('1')) return false;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const [_major, minor, patch] = version.split('.').map((n) => parseInt(n));\n\n    // we need a patch if semver:minor is < 15 and semver:patch < 1\n    return minor > 14 ? false : minor < 15 && patch < 1;\n})();\n\ninterface CreateStreamOps {\n    type?: StreamType;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data?: any;\n    disableVolume?: boolean;\n    disableEqualizer?: boolean;\n    disableBiquad?: boolean;\n    eq?: EqualizerBand[];\n    biquadFilter?: BiquadFilters;\n    disableFilters?: boolean;\n    defaultFilters?: PCMFilters[];\n    volume?: number;\n    disableResampler?: boolean;\n    sampleRate?: number;\n}\n\nexport interface VoiceEvents {\n    /* eslint-disable @typescript-eslint/no-explicit-any */\n    error: (error: AudioPlayerError) => any;\n    debug: (message: string) => any;\n    start: (resource: AudioResource<Track>) => any;\n    finish: (resource: AudioResource<Track>) => any;\n    dsp: (filters: PCMFilters[]) => any;\n    eqBands: (filters: EqualizerBand[]) => any;\n    sampleRate: (filters: number) => any;\n    biquad: (filters: BiquadFilters) => any;\n    volume: (volume: number) => any;\n    /* eslint-enable @typescript-eslint/no-explicit-any */\n}\n\nclass StreamDispatcher extends EventEmitter<VoiceEvents> {\n    public readonly voiceConnection: VoiceConnection;\n    public readonly audioPlayer: AudioPlayer;\n    public receiver = new VoiceReceiverNode(this);\n    public channel: VoiceChannel | StageChannel;\n    public audioResource?: AudioResource<Track> | null;\n    private readyLock = false;\n    public dsp = new FiltersChain();\n\n    /**\n     * Creates new connection object\n     * @param {VoiceConnection} connection The connection\n     * @param {VoiceChannel|StageChannel} channel The connected channel\n     * @private\n     */\n    constructor(connection: VoiceConnection, channel: VoiceChannel | StageChannel, public queue: GuildQueue, public readonly connectionTimeout: number = 20000) {\n        super();\n\n        /**\n         * The voice connection\n         * @type {VoiceConnection}\n         */\n        this.voiceConnection = connection;\n\n        /**\n         * The audio player\n         * @type {AudioPlayer}\n         */\n        this.audioPlayer = createAudioPlayer();\n\n        /**\n         * The voice channel\n         * @type {VoiceChannel|StageChannel}\n         */\n        this.channel = channel;\n\n        this.voiceConnection.on('debug', (m) => void this.emit('debug', m));\n        this.voiceConnection.on('error', (error) => void this.emit('error', error as AudioPlayerError));\n        this.audioPlayer.on('debug', (m) => void this.emit('debug', m));\n        this.audioPlayer.on('error', (error) => void this.emit('error', error));\n\n        this.dsp.onUpdate = () => {\n            if (!this.dsp) return;\n            if (this.dsp.filters?.filters) this.emit('dsp', this.dsp.filters?.filters);\n            if (this.dsp.biquad?.filter) this.emit('biquad', this.dsp.biquad?.filter);\n            if (this.dsp.equalizer) this.emit('eqBands', this.dsp.equalizer.getEQ());\n            if (this.dsp.volume) this.emit('volume', this.dsp.volume.volume);\n            if (this.dsp.resampler) this.emit('sampleRate', this.dsp.resampler.targetSampleRate);\n        };\n\n        this.dsp.onError = (e) => this.emit('error', e as AudioPlayerError);\n\n        this.voiceConnection.on('stateChange', async (oldState, newState) => {\n            if (needsKeepAlivePatch) {\n                this.queue.debug(`Detected @discordjs/voice version ${version} which needs keepAlive patch, applying patch...`);\n                const oldNetworking = Reflect.get(oldState, 'networking');\n                const newNetworking = Reflect.get(newState, 'networking');\n\n                const networkStateChangeHandler = (_: object, newNetworkState: object) => {\n                    const newUdp = Reflect.get(newNetworkState, 'udp');\n                    clearInterval(newUdp?.keepAliveInterval);\n                };\n\n                oldNetworking?.off('stateChange', networkStateChangeHandler);\n                newNetworking?.on('stateChange', networkStateChangeHandler);\n            }\n\n            if (newState.status === VoiceConnectionStatus.Disconnected) {\n                if (newState.reason === VoiceConnectionDisconnectReason.WebSocketClose && newState.closeCode === 4014) {\n                    try {\n                        await entersState(this.voiceConnection, VoiceConnectionStatus.Connecting, this.connectionTimeout);\n                    } catch {\n                        try {\n                            if (this.voiceConnection.state.status !== VoiceConnectionStatus.Destroyed) this.voiceConnection.destroy();\n                        } catch (err) {\n                            this.emit('error', err as AudioPlayerError);\n                        }\n                    }\n                } else if (this.voiceConnection.rejoinAttempts < 5) {\n                    await Util.wait((this.voiceConnection.rejoinAttempts + 1) * 5000);\n                    this.voiceConnection.rejoin();\n                } else {\n                    try {\n                        if (this.voiceConnection.state.status !== VoiceConnectionStatus.Destroyed) this.voiceConnection.destroy();\n                    } catch (err) {\n                        this.emit('error', err as AudioPlayerError);\n                    }\n                }\n            } else if (newState.status === VoiceConnectionStatus.Destroyed) {\n                this.end();\n            } else if (!this.readyLock && (newState.status === VoiceConnectionStatus.Connecting || newState.status === VoiceConnectionStatus.Signalling)) {\n                this.readyLock = true;\n                try {\n                    await entersState(this.voiceConnection, VoiceConnectionStatus.Ready, this.connectionTimeout);\n                } catch {\n                    if (this.voiceConnection.state.status !== VoiceConnectionStatus.Destroyed) {\n                        try {\n                            this.voiceConnection.destroy();\n                        } catch (err) {\n                            this.emit('error', err as AudioPlayerError);\n                        }\n                    }\n                } finally {\n                    this.readyLock = false;\n                }\n            }\n        });\n\n        this.audioPlayer.on('stateChange', (oldState, newState) => {\n            if (newState.status === AudioPlayerStatus.Playing) {\n                if (oldState.status === AudioPlayerStatus.Idle || oldState.status === AudioPlayerStatus.Buffering) {\n                    return this.emit('start', this.audioResource!);\n                }\n            } else if (newState.status === AudioPlayerStatus.Idle && oldState.status !== AudioPlayerStatus.Idle) {\n                this.emit('finish', this.audioResource!);\n                this.dsp.destroy();\n                this.audioResource = null;\n            }\n        });\n\n        this.voiceConnection.subscribe(this.audioPlayer);\n    }\n\n    /**\n     * Check if the player has been paused manually\n     */\n    get paused() {\n        return this.audioPlayer.state.status === AudioPlayerStatus.Paused;\n    }\n\n    set paused(val: boolean) {\n        val ? this.pause(true) : this.resume();\n    }\n\n    /**\n     * Whether or not the player is currently paused automatically or manually.\n     */\n    isPaused() {\n        return this.paused || this.audioPlayer.state.status === AudioPlayerStatus.AutoPaused;\n    }\n\n    /**\n     * Whether or not the player is currently buffering\n     */\n    isBuffering() {\n        return this.audioPlayer.state.status === AudioPlayerStatus.Buffering;\n    }\n\n    /**\n     * Whether or not the player is currently playing\n     */\n    isPlaying() {\n        return this.audioPlayer.state.status === AudioPlayerStatus.Playing;\n    }\n\n    /**\n     * Whether or not the player is currently idle\n     */\n    isIdle() {\n        return this.audioPlayer.state.status === AudioPlayerStatus.Idle;\n    }\n\n    /**\n     * Whether or not the voice connection has been destroyed\n     */\n    isDestroyed() {\n        return this.voiceConnection.state.status === VoiceConnectionStatus.Destroyed;\n    }\n\n    /**\n     * Whether or not the voice connection has been destroyed\n     */\n    isDisconnected() {\n        return this.voiceConnection.state.status === VoiceConnectionStatus.Disconnected;\n    }\n\n    /**\n     * Whether or not the voice connection is ready to play\n     */\n    isReady() {\n        return this.voiceConnection.state.status === VoiceConnectionStatus.Ready;\n    }\n\n    /**\n     * Whether or not the voice connection is signalling\n     */\n    isSignalling() {\n        return this.voiceConnection.state.status === VoiceConnectionStatus.Signalling;\n    }\n\n    /**\n     * Whether or not the voice connection is connecting\n     */\n    isConnecting() {\n        return this.voiceConnection.state.status === VoiceConnectionStatus.Connecting;\n    }\n\n    /**\n     * Creates stream\n     * @param {Readable} src The stream source\n     * @param {object} [ops] Options\n     * @returns {AudioResource}\n     */\n    async createStream(src: Readable, ops?: CreateStreamOps) {\n        if (!ops?.disableFilters) this.queue.debug('Initiating DSP filters pipeline...');\n        const stream = !ops?.disableFilters\n            ? this.dsp.create(src, {\n                  dsp: {\n                      filters: ops?.defaultFilters,\n                      disabled: ops?.disableFilters\n                  },\n                  biquad: ops?.biquadFilter\n                      ? {\n                            filter: ops.biquadFilter,\n                            disabled: ops?.disableBiquad\n                        }\n                      : undefined,\n                  resampler: {\n                      targetSampleRate: ops?.sampleRate,\n                      disabled: ops?.disableResampler\n                  },\n                  equalizer: {\n                      bandMultiplier: ops?.eq,\n                      disabled: ops?.disableEqualizer\n                  },\n                  volume: {\n                      volume: ops?.volume,\n                      disabled: ops?.disableVolume\n                  }\n              })\n            : src;\n\n        this.queue.debug('Executing onAfterCreateStream hook...');\n        const postStream = await this.queue.onAfterCreateStream?.(stream, this.queue).catch(\n            () =>\n                ({\n                    stream: stream,\n                    type: ops?.type ?? StreamType.Arbitrary\n                } as PostProcessedResult)\n        );\n\n        this.queue.debug('Preparing AudioResource...');\n        this.audioResource = createAudioResource(postStream?.stream ?? stream, {\n            inputType: postStream?.type ?? ops?.type ?? StreamType.Arbitrary,\n            metadata: ops?.data,\n            // volume controls happen from AudioFilter DSP utility\n            inlineVolume: false\n        });\n\n        return this.audioResource;\n    }\n\n    public get resampler() {\n        return this.dsp?.resampler;\n    }\n\n    public get filters() {\n        return this.dsp?.filters;\n    }\n\n    public get biquad() {\n        return this.dsp?.biquad || null;\n    }\n\n    public get equalizer() {\n        return this.dsp?.equalizer || null;\n    }\n\n    /**\n     * The player status\n     * @type {AudioPlayerStatus}\n     */\n    get status() {\n        return this.audioPlayer.state.status;\n    }\n\n    /**\n     * Disconnects from voice\n     * @returns {void}\n     */\n    disconnect() {\n        try {\n            if (this.audioPlayer) this.audioPlayer.stop(true);\n            if (this.voiceConnection.state.status !== VoiceConnectionStatus.Destroyed) this.voiceConnection.destroy();\n        } catch {} // eslint-disable-line no-empty\n    }\n\n    /**\n     * Stops the player\n     * @returns {void}\n     */\n    end() {\n        try {\n            this.audioPlayer.stop();\n        } catch {\n            //\n        }\n    }\n\n    /**\n     * Pauses the stream playback\n     * @param {boolean} [interpolateSilence=false] If true, the player will play 5 packets of silence after pausing to prevent audio glitches.\n     * @returns {boolean}\n     */\n    pause(interpolateSilence?: boolean) {\n        const success = this.audioPlayer.pause(interpolateSilence);\n        return success;\n    }\n\n    /**\n     * Resumes the stream playback\n     * @returns {boolean}\n     */\n    resume() {\n        const success = this.audioPlayer.unpause();\n        return success;\n    }\n\n    /**\n     * Play stream\n     * @param {AudioResource<Track>} [resource=this.audioResource] The audio resource to play\n     * @returns {Promise<StreamDispatcher>}\n     */\n    async playStream(resource: AudioResource<Track> = this.audioResource!) {\n        if (!resource) throw new PlayerError('Audio resource is not available!', ErrorStatusCode.NO_AUDIO_RESOURCE);\n        if (resource.ended) {\n            return void this.emit('finish', resource);\n        }\n        if (!this.audioResource) this.audioResource = resource;\n        if (this.voiceConnection.state.status !== VoiceConnectionStatus.Ready) {\n            try {\n                await entersState(this.voiceConnection, VoiceConnectionStatus.Ready, this.connectionTimeout);\n            } catch (err) {\n                return void this.emit('error', err as AudioPlayerError);\n            }\n        }\n\n        try {\n            this.audioPlayer.play(resource);\n        } catch (e) {\n            this.emit('error', e as AudioPlayerError);\n        }\n\n        return this;\n    }\n\n    /**\n     * Sets playback volume\n     * @param {number} value The volume amount\n     * @returns {boolean}\n     */\n    setVolume(value: number) {\n        if (!this.dsp.volume) return false;\n        return this.dsp.volume.setVolume(value);\n    }\n\n    /**\n     * The current volume\n     * @type {number}\n     */\n    get volume() {\n        if (!this.dsp.volume) return 100;\n        return this.dsp.volume.volume;\n    }\n\n    /**\n     * The playback time\n     * @type {number}\n     */\n    get streamTime() {\n        if (!this.audioResource) return 0;\n        return this.audioResource.playbackDuration;\n    }\n}\n\nexport { StreamDispatcher as StreamDispatcher };\n","import { Player } from '../Player';\nimport { SearchResult } from '../Structures/SearchResult';\nimport { Track } from '../Structures/Track';\nimport { User } from 'discord.js';\nimport { SearchQueryType } from '../types/types';\n\nexport interface QueryCacheOptions {\n    checkInterval?: number;\n}\n\n// 5h\nconst DEFAULT_EXPIRY_TIMEOUT = 18_000_000;\n\nexport class QueryCache {\n    #defaultCache = new Map<string, DiscordPlayerQueryResultCache<Track>>();\n    public timer: NodeJS.Timer;\n    public constructor(\n        public player: Player,\n        public options: QueryCacheOptions = {\n            checkInterval: DEFAULT_EXPIRY_TIMEOUT\n        }\n    ) {\n        this.timer = setInterval(this.cleanup.bind(this), this.checkInterval).unref();\n    }\n\n    public get checkInterval() {\n        return this.options.checkInterval ?? DEFAULT_EXPIRY_TIMEOUT;\n    }\n\n    public async cleanup() {\n        for (const [id, value] of this.#defaultCache) {\n            if (value.hasExpired()) {\n                this.#defaultCache.delete(id);\n            }\n        }\n    }\n\n    public async clear() {\n        this.#defaultCache.clear();\n    }\n\n    public async getData() {\n        return [...this.#defaultCache.values()];\n    }\n\n    public async addData(data: SearchResult) {\n        data.tracks.forEach((d) => {\n            if (this.#defaultCache.has(d.url)) return;\n            this.#defaultCache.set(d.url, new DiscordPlayerQueryResultCache(d));\n        });\n    }\n\n    public async resolve(context: QueryCacheResolverContext) {\n        const result = this.#defaultCache.get(context.query);\n        if (!result)\n            return new SearchResult(this.player, {\n                query: context.query,\n                requestedBy: context.requestedBy,\n                queryType: context.queryType\n            });\n\n        return new SearchResult(this.player, {\n            query: context.query,\n            tracks: [result.data],\n            playlist: null,\n            queryType: context.queryType,\n            requestedBy: context.requestedBy\n        });\n    }\n}\n\nexport class DiscordPlayerQueryResultCache<T = unknown> {\n    public expireAfter = DEFAULT_EXPIRY_TIMEOUT;\n    public constructor(public data: T, expireAfter: number = DEFAULT_EXPIRY_TIMEOUT) {\n        if (typeof expireAfter === 'number') {\n            this.expireAfter = Date.now() + expireAfter;\n        }\n    }\n\n    public hasExpired() {\n        if (typeof this.expireAfter !== 'number' || isNaN(this.expireAfter) || this.expireAfter < 1) return false;\n        return Date.now() <= this.expireAfter;\n    }\n}\n\nexport interface QueryCacheResolverContext {\n    query: string;\n    requestedBy?: User;\n    queryType?: SearchQueryType | `ext:${string}`;\n}\n","import { Client, SnowflakeUtil, VoiceState, IntentsBitField, User, ChannelType, GuildVoiceChannelResolvable } from 'discord.js';\nimport { Playlist, Track, GuildQueueEvents, VoiceConnectConfig, GuildNodeCreateOptions, GuildNodeManager, SearchResult, GuildQueue } from './Structures';\nimport { VoiceUtils } from './VoiceInterface/VoiceUtils';\nimport { PlayerEvents, QueryType, SearchOptions, PlayerInitOptions, PlaylistInitData, SearchQueryType } from './types/types';\nimport { QueryResolver } from './utils/QueryResolver';\nimport { Util } from './utils/Util';\nimport { generateDependencyReport } from '@discordjs/voice';\nimport { ExtractorExecutionContext } from './extractors/ExtractorExecutionContext';\nimport { BaseExtractor } from './extractors/BaseExtractor';\nimport * as _internals from './utils/__internal__';\nimport { QueryCache } from './utils/QueryCache';\nimport { PlayerEventsEmitter } from './utils/PlayerEventsEmitter';\n\nconst kSingleton = Symbol('InstanceDiscordPlayerSingleton');\n\nexport interface PlayerNodeInitializationResult<T = unknown> {\n    track: Track;\n    extractor: BaseExtractor | null;\n    searchResult: SearchResult;\n    queue: GuildQueue<T>;\n}\n\nexport class Player extends PlayerEventsEmitter<PlayerEvents> {\n    #lastLatency = -1;\n    #voiceStateUpdateListener = this.handleVoiceState.bind(this);\n    #lagMonitorTimeout!: NodeJS.Timeout;\n    #lagMonitorInterval!: NodeJS.Timer;\n    public static _singletonKey = kSingleton;\n    public readonly id = SnowflakeUtil.generate().toString();\n    public readonly client!: Client;\n    public readonly options!: PlayerInitOptions;\n    public nodes = new GuildNodeManager(this);\n    public readonly voiceUtils = new VoiceUtils(this);\n    public extractors = new ExtractorExecutionContext(this);\n    public events = new PlayerEventsEmitter<GuildQueueEvents>(['error', 'playerError']);\n\n    /**\n     * Creates new Discord Player\n     * @param {Client} client The Discord Client\n     * @param {PlayerInitOptions} [options] The player init options\n     */\n    public constructor(client: Client, options: PlayerInitOptions = {}) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (!options.ignoreInstance && kSingleton in Player) return (<any>Player)[kSingleton] as Player;\n\n        super(['error']);\n\n        /**\n         * The discord.js client\n         * @type {Client}\n         */\n        this.client = client;\n\n        if (this.client?.options?.intents && !new IntentsBitField(this.client?.options?.intents).has(IntentsBitField.Flags.GuildVoiceStates)) {\n            Util.warn('client is missing \"GuildVoiceStates\" intent', 'InvalidIntentsBitField');\n        }\n\n        /**\n         * The extractors collection\n         * @type {ExtractorModel}\n         */\n        this.options = {\n            autoRegisterExtractor: true,\n            lockVoiceStateHandler: false,\n            blockExtractors: [],\n            blockStreamFrom: [],\n            connectionTimeout: 20000,\n            smoothVolume: true,\n            lagMonitor: 30000,\n            queryCache: options.queryCache === null ? null : new QueryCache(this),\n            ...options,\n            ytdlOptions: {\n                highWaterMark: 1 << 25,\n                ...options.ytdlOptions\n            }\n        };\n\n        this.client.on('voiceStateUpdate', this.#voiceStateUpdateListener);\n\n        if (this.options?.autoRegisterExtractor) {\n            this.extractors.loadDefault().then((r) => {\n                if (r.error) {\n                    this.emit('error', new Error(`Failed to load default extractors: ${r.error?.stack ?? r.error}`));\n                } else {\n                    this.debug('Default extractors loaded!');\n                }\n\n                this.debug(`[Dependencies Report]\\n${this.scanDeps()}`);\n            });\n        }\n\n        if (typeof this.options.lagMonitor === 'number' && this.options.lagMonitor > 0) {\n            this.#lagMonitorInterval = setInterval(() => {\n                const start = performance.now();\n                this.#lagMonitorTimeout = setTimeout(() => {\n                    this.#lastLatency = performance.now() - start;\n                    this.debug(`[Lag Monitor] Event loop latency: ${this.#lastLatency}ms`);\n                }, 0).unref();\n            }, this.options.lagMonitor).unref();\n        }\n\n        _internals.addPlayer(this);\n\n        if (!(kSingleton in Player)) {\n            Object.defineProperty(Player, kSingleton, {\n                value: this,\n                writable: true,\n                configurable: true,\n                enumerable: false\n            });\n        }\n    }\n\n    public debug(m: string) {\n        return this.emit('debug', m);\n    }\n\n    /**\n     * Creates discord-player singleton instance.\n     * @param client The client that instantiated player\n     * @param options Player initializer options\n     */\n    public static singleton(client: Client, options: PlayerInitOptions = {}) {\n        return new Player(client, {\n            ...options,\n            ignoreInstance: false\n        });\n    }\n\n    /**\n     * Get all active player instances\n     */\n    public static getAllPlayers() {\n        return _internals.getPlayers();\n    }\n\n    /**\n     * Clear all player instances\n     */\n    public static clearAllPlayers() {\n        return _internals.instances.clear();\n    }\n\n    /**\n     * The current query cache provider\n     */\n    public get queryCache() {\n        return this.options.queryCache ?? null;\n    }\n\n    /**\n     * Alias to `Player.nodes`\n     */\n    public get queues() {\n        return this.nodes;\n    }\n\n    /**\n     * Event loop lag\n     * @type {number}\n     */\n    public get eventLoopLag() {\n        return this.#lastLatency;\n    }\n\n    /**\n     * Generates statistics\n     */\n    public generateStatistics() {\n        return {\n            instances: _internals.instances.size,\n            queuesCount: this.queues.cache.size,\n            queryCacheEnabled: this.queryCache != null,\n            queues: this.queues.cache.map((m) => m.stats.generate())\n        };\n    }\n\n    /**\n     * Destroy player\n     */\n    public async destroy() {\n        this.nodes.cache.forEach((node) => node.delete());\n        this.client.off('voiceStateUpdate', this.#voiceStateUpdateListener);\n        this.removeAllListeners();\n        this.events.removeAllListeners();\n        await this.extractors.unregisterAll();\n        if (this.#lagMonitorInterval) clearInterval(this.#lagMonitorInterval);\n        if (this.#lagMonitorTimeout) clearInterval(this.#lagMonitorTimeout);\n        _internals.clearPlayer(this);\n    }\n\n    private _handleVoiceState(oldState: VoiceState, newState: VoiceState) {\n        const queue = this.nodes.get(oldState.guild.id);\n        if (!queue || !queue.connection || !queue.channel) return;\n\n        // dispatch voice state update\n        const wasHandled = this.events.emit('voiceStateUpdate', queue, oldState, newState);\n        // if the event was handled, return assuming the listener implemented all of the logic below\n        if (wasHandled && !this.options.lockVoiceStateHandler) return;\n\n        if (oldState.channelId && !newState.channelId && newState.member?.id === newState.guild.members.me?.id) {\n            try {\n                queue.delete();\n            } catch {\n                /* noop */\n            }\n            return void this.events.emit('disconnect', queue);\n        }\n\n        if (!oldState.channelId && newState.channelId && newState.member?.id === newState.guild.members.me?.id) {\n            if (newState.serverMute != null && oldState.serverMute !== newState.serverMute) {\n                queue.node.setPaused(newState.serverMute);\n            } else if (newState.channel?.type === ChannelType.GuildStageVoice && newState.suppress != null && oldState.suppress !== newState.suppress) {\n                queue.node.setPaused(newState.suppress);\n                if (newState.suppress) {\n                    newState.guild.members.me?.voice.setRequestToSpeak(true).catch(Util.noop);\n                }\n            }\n        }\n\n        if (!newState.channelId && oldState.channelId === queue.channel.id) {\n            if (!Util.isVoiceEmpty(queue.channel)) return;\n            const timeout = setTimeout(() => {\n                if (!Util.isVoiceEmpty(queue.channel!)) return;\n                if (!this.nodes.has(queue.guild.id)) return;\n                if (queue.options.leaveOnEmpty) queue.delete();\n                this.events.emit('emptyChannel', queue);\n            }, queue.options.leaveOnEmptyCooldown || 0).unref();\n            queue.timeouts.set(`empty_${oldState.guild.id}`, timeout);\n        }\n\n        if (newState.channelId && newState.channelId === queue.channel.id) {\n            const emptyTimeout = queue.timeouts.get(`empty_${oldState.guild.id}`);\n            const channelEmpty = Util.isVoiceEmpty(queue.channel);\n            if (!channelEmpty && emptyTimeout) {\n                clearTimeout(emptyTimeout);\n                queue.timeouts.delete(`empty_${oldState.guild.id}`);\n            }\n        }\n\n        if (oldState.channelId && newState.channelId && oldState.channelId !== newState.channelId) {\n            if (newState.member?.id === newState.guild.members.me?.id) {\n                if (queue.connection && newState.member?.id === newState.guild.members.me?.id) queue.channel = newState.channel!;\n                const emptyTimeout = queue.timeouts.get(`empty_${oldState.guild.id}`);\n                const channelEmpty = Util.isVoiceEmpty(queue.channel);\n                if (!channelEmpty && emptyTimeout) {\n                    clearTimeout(emptyTimeout);\n                    queue.timeouts.delete(`empty_${oldState.guild.id}`);\n                } else {\n                    const timeout = setTimeout(() => {\n                        if (queue.connection && !Util.isVoiceEmpty(queue.channel!)) return;\n                        if (!this.nodes.has(queue.guild.id)) return;\n                        if (queue.options.leaveOnEmpty) queue.delete();\n                        this.events.emit('emptyChannel', queue);\n                    }, queue.options.leaveOnEmptyCooldown || 0).unref();\n                    queue.timeouts.set(`empty_${oldState.guild.id}`, timeout);\n                }\n            } else {\n                if (newState.channelId !== queue.channel.id) {\n                    if (!Util.isVoiceEmpty(queue.channel)) return;\n                    if (queue.timeouts.has(`empty_${oldState.guild.id}`)) return;\n                    const timeout = setTimeout(() => {\n                        if (!Util.isVoiceEmpty(queue.channel!)) return;\n                        if (!this.nodes.has(queue.guild.id)) return;\n                        if (queue.options.leaveOnEmpty) queue.delete();\n                        this.events.emit('emptyChannel', queue);\n                    }, queue.options.leaveOnEmptyCooldown || 0).unref();\n                    queue.timeouts.set(`empty_${oldState.guild.id}`, timeout);\n                } else {\n                    const emptyTimeout = queue.timeouts.get(`empty_${oldState.guild.id}`);\n                    const channelEmpty = Util.isVoiceEmpty(queue.channel!);\n                    if (!channelEmpty && emptyTimeout) {\n                        clearTimeout(emptyTimeout);\n                        queue.timeouts.delete(`empty_${oldState.guild.id}`);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Handles voice state update\n     * @param {VoiceState} oldState The old voice state\n     * @param {VoiceState} newState The new voice state\n     * @returns {void}\n     */\n    public handleVoiceState(oldState: VoiceState, newState: VoiceState): void {\n        this._handleVoiceState(oldState, newState);\n    }\n\n    /**\n     * Lock voice state handler\n     */\n    public lockVoiceStateHandler() {\n        this.options.lockVoiceStateHandler = true;\n    }\n\n    /**\n     * Unlock voice state handler\n     */\n    public unlockVoiceStateHandler() {\n        this.options.lockVoiceStateHandler = false;\n    }\n\n    /**\n     * Checks if voice state handler is locked\n     */\n    public isVoiceStateHandlerLocked() {\n        return !!this.options.lockVoiceStateHandler;\n    }\n\n    /**\n     * Initiate audio player\n     * @param channel The voice channel on which the music should be played\n     * @param query The track or source to play\n     * @param options Options for player\n     */\n    public async play<T = unknown>(\n        channel: GuildVoiceChannelResolvable,\n        query: string | Track | SearchResult | Track[] | Playlist,\n        options: SearchOptions & {\n            nodeOptions?: GuildNodeCreateOptions<T>;\n            connectionOptions?: VoiceConnectConfig;\n            afterSearch?: (result: SearchResult) => Promise<SearchResult>;\n        } = {}\n    ): Promise<PlayerNodeInitializationResult<T>> {\n        const vc = this.client.channels.resolve(channel);\n        if (!vc?.isVoiceBased()) throw new Error('Expected a voice channel');\n\n        const originalResult = query instanceof SearchResult ? query : await this.search(query, options);\n        const result = (await options.afterSearch?.(originalResult)) || originalResult;\n        if (result.isEmpty()) {\n            throw new Error(`No results found for \"${query}\" (Extractor: ${result.extractor?.identifier || 'N/A'})`);\n        }\n\n        const queue = this.nodes.create(vc.guild, options.nodeOptions);\n        if (!queue.channel) await queue.connect(vc, options.connectionOptions);\n\n        if (!result.playlist) {\n            queue.addTrack(result.tracks[0]);\n        } else {\n            queue.addTrack(result.playlist);\n        }\n\n        if (!queue.isPlaying()) await queue.node.play();\n\n        return {\n            track: result.tracks[0],\n            extractor: result.extractor,\n            searchResult: result,\n            queue\n        };\n    }\n\n    /**\n     * @typedef {object} PlayerSearchResult\n     * @property {Playlist} [playlist] The playlist (if any)\n     * @property {Track[]} tracks The tracks\n     */\n    /**\n     * Search tracks\n     * @param {string | Track | Track[] | Playlist | SearchResult} query The search query\n     * @param {SearchOptions} options The search options\n     * @returns {Promise<SearchResult>}\n     */\n    public async search(query: string | Track | Track[] | Playlist | SearchResult, options: SearchOptions = {}): Promise<SearchResult> {\n        if (query instanceof SearchResult) return query;\n\n        if (options.requestedBy != null) options.requestedBy = this.client.users.resolve(options.requestedBy)!;\n        options.blockExtractors ??= this.options.blockExtractors;\n        options.fallbackSearchEngine ??= QueryType.AUTO_SEARCH;\n\n        if (query instanceof Track) {\n            return new SearchResult(this, {\n                playlist: query.playlist || null,\n                tracks: [query],\n                query: query.title,\n                extractor: query.extractor,\n                queryType: query.queryType,\n                requestedBy: options.requestedBy\n            });\n        }\n\n        if (query instanceof Playlist) {\n            return new SearchResult(this, {\n                playlist: query,\n                tracks: query.tracks,\n                query: query.title,\n                extractor: query.tracks[0]?.extractor,\n                queryType: QueryType.AUTO,\n                requestedBy: options.requestedBy\n            });\n        }\n\n        if (Array.isArray(query)) {\n            const tracks = query.filter((t) => t instanceof Track);\n            return new SearchResult(this, {\n                playlist: null,\n                tracks,\n                query: '@@#%{{UserLoadedContent}}%#@@',\n                extractor: null,\n                queryType: QueryType.AUTO,\n                requestedBy: options.requestedBy\n            });\n        }\n\n        this.debug(`Searching ${query}`);\n\n        let extractor: BaseExtractor | null = null;\n\n        options.searchEngine ??= QueryType.AUTO;\n\n        this.debug(`Search engine set to ${options.searchEngine}`);\n\n        const queryType = options.searchEngine === QueryType.AUTO ? QueryResolver.resolve(query, options.fallbackSearchEngine) : options.searchEngine;\n\n        this.debug(`Query type identified as ${queryType}`);\n\n        // force particular extractor\n        if (options.searchEngine.startsWith('ext:')) {\n            extractor = this.extractors.get(options.searchEngine.substring(4))!;\n            if (!extractor)\n                return new SearchResult(this, {\n                    query,\n                    queryType,\n                    extractor,\n                    requestedBy: options.requestedBy\n                });\n        }\n\n        // query all extractors\n        if (!extractor) {\n            // cache validation\n            if (!options.ignoreCache) {\n                this.debug(`Checking cache...`);\n                const res = await this.queryCache?.resolve({\n                    query,\n                    queryType,\n                    requestedBy: options.requestedBy\n                });\n                // cache hit\n                if (res?.hasTracks()) {\n                    this.debug(`Cache hit for query ${query}`);\n                    return res;\n                }\n\n                this.debug(`Cache miss for query ${query}`);\n            }\n\n            this.debug(`Executing extractors...`);\n\n            // cache miss\n            extractor =\n                (\n                    await this.extractors.run(async (ext) => {\n                        if (options.blockExtractors?.includes(ext.identifier)) return false;\n                        return ext.validate(query, queryType as SearchQueryType);\n                    })\n                )?.extractor || null;\n        }\n\n        // no extractors available\n        if (!extractor) {\n            this.debug('Failed to find appropriate extractor');\n            return new SearchResult(this, {\n                query,\n                queryType,\n                requestedBy: options.requestedBy\n            });\n        }\n\n        this.debug(`Executing metadata query using ${extractor.identifier} extractor...`);\n        const res = await extractor\n            .handle(query, {\n                type: queryType as SearchQueryType,\n                requestedBy: options.requestedBy as User\n            })\n            .catch(() => null);\n\n        if (res) {\n            this.debug('Metadata query was successful!');\n            const result = new SearchResult(this, {\n                query,\n                queryType,\n                playlist: res.playlist,\n                tracks: res.tracks,\n                extractor,\n                requestedBy: options.requestedBy\n            });\n\n            if (!options.ignoreCache) {\n                this.debug(`Adding data to cache...`);\n                await this.queryCache?.addData(result);\n            }\n\n            return result;\n        }\n\n        this.debug('Failed to find result using appropriate extractor. Querying all extractors...');\n        const result = await this.extractors.run(\n            async (ext) =>\n                !options.blockExtractors?.includes(ext.identifier) &&\n                (await ext.validate(query)) &&\n                ext.handle(query, {\n                    type: queryType as SearchQueryType,\n                    requestedBy: options.requestedBy as User\n                })\n        );\n        if (!result?.result) {\n            this.debug(`Failed to query metadata query using ${result?.extractor.identifier || 'N/A'} extractor.`);\n            return new SearchResult(this, {\n                query,\n                queryType,\n                requestedBy: options.requestedBy,\n                extractor: result?.extractor\n            });\n        }\n\n        this.debug(`Metadata query was successful using ${result.extractor.identifier}!`);\n\n        const data = new SearchResult(this, {\n            query,\n            queryType,\n            playlist: result.result.playlist,\n            tracks: result.result.tracks,\n            extractor: result.extractor,\n            requestedBy: options.requestedBy\n        });\n\n        if (!options.ignoreCache) {\n            this.debug(`Adding data to cache...`);\n            await this.queryCache?.addData(data);\n        }\n\n        return data;\n    }\n\n    /**\n     * Generates a report of the dependencies used by the `@discordjs/voice` module. Useful for debugging.\n     * @returns {string}\n     */\n    public scanDeps() {\n        const line = '-'.repeat(50);\n        const depsReport = generateDependencyReport();\n        const extractorReport = this.extractors.store\n            .map((m) => {\n                return m.identifier;\n            })\n            .join('\\n');\n        return `${depsReport}\\nLoaded Extractors:\\n${extractorReport || 'None'}\\n${line}`;\n    }\n\n    public *[Symbol.iterator]() {\n        yield* this.nodes.cache.values();\n    }\n\n    /**\n     * Creates `Playlist` instance\n     * @param data The data to initialize a playlist\n     */\n    public createPlaylist(data: PlaylistInitData) {\n        return new Playlist(this, data);\n    }\n}\n","import { GuildQueue, NodeResolvable } from '../Structures';\nimport { instances } from '../utils/__internal__';\n\nexport const getPlayer = () => {\n    return instances.first() || null;\n};\n\nexport const getQueue = <T = unknown>(node: NodeResolvable) => {\n    const player = getPlayer();\n    if (!player) return null;\n\n    return (player.nodes.resolve(node) as GuildQueue<T>) || null;\n};\n","import { NodeResolvable } from '../Structures';\nimport { getQueue } from './common';\n\nexport function useHistory<Meta = unknown>(node: NodeResolvable) {\n    const queue = getQueue<Meta>(node);\n    if (!queue) return null;\n\n    return queue.history;\n}\n","import { NodeResolvable } from '../Structures';\nimport { getQueue } from './common';\n\nexport function usePlayer<Meta = unknown>(node: NodeResolvable) {\n    const queue = getQueue<Meta>(node);\n    if (!queue) return null;\n\n    return queue.node;\n}\n","import { NodeResolvable } from '../Structures';\nimport { getQueue } from './common';\n\nexport function useQueue<Meta = unknown>(node: NodeResolvable) {\n    const queue = getQueue<Meta>(node);\n    if (!queue) return null;\n\n    return queue;\n}\n","import { getPlayer } from './common';\n\nexport function useMasterPlayer() {\n    return getPlayer();\n}\n","import { NodeResolvable } from '../Structures';\nimport { getQueue } from './common';\n\nexport function useMetadata<T = unknown>(node: NodeResolvable) {\n    const queue = getQueue(node);\n    const setter = (metadata: T | null) => {\n        if (queue) {\n            queue.setMetadata(metadata);\n        }\n    };\n\n    const getter = () => {\n        return queue?.metadata as T;\n    };\n\n    return [getter, setter] as const;\n}\n","import { NodeResolvable } from '../Structures';\nimport { getQueue } from './common';\n\nexport interface TimelineDispatcherOptions {\n    ignoreFilters: boolean;\n}\n\nexport function useTimeline(node: NodeResolvable, options?: Partial<TimelineDispatcherOptions>) {\n    const queue = getQueue(node);\n    if (!queue) return null;\n\n    return Object.preventExtensions({\n        get timestamp() {\n            return queue.node.getTimestamp(options?.ignoreFilters)!;\n        },\n        get volume() {\n            return queue.node.volume;\n        },\n        get paused() {\n            return queue.node.isPaused();\n        },\n        pause() {\n            return queue.node.pause();\n        },\n        resume() {\n            return queue.node.resume();\n        },\n        setVolume(vol: number) {\n            return queue.node.setVolume(vol);\n        },\n        async setPosition(time: number) {\n            return queue.node.seek(time);\n        }\n    });\n}\n","import { OnAfterCreateStreamHandler } from '../../Structures';\nimport { getGlobalRegistry } from '../../utils/__internal__';\n\nexport function onAfterCreateStream(handler: OnAfterCreateStreamHandler) {\n    getGlobalRegistry().set('@[onAfterCreateStream]', handler);\n}\n","import { OnBeforeCreateStreamHandler } from '../../Structures';\nimport { getGlobalRegistry } from '../../utils/__internal__';\n\nexport function onBeforeCreateStream(handler: OnBeforeCreateStreamHandler) {\n    getGlobalRegistry().set('@[onBeforeCreateStream]', handler);\n}\n"],"mappings":"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","names":["setTimeout","setTimeout","Collection","Collection","Queue","StreamType","PlayerEvent","QueueRepeatMode","setTimeout","GuildQueueEvent","StreamType","Collection","Queue","setTimeout","Collection","Collection","prism","ErrorStatusCode","VoiceConnectionStatus","StreamType","EventEmitter","EventEmitter","StreamType","Collection","Collection","VoiceConnectionStatus","SnowflakeUtil","ChannelType","SnowflakeUtil","ChannelType","res","result","AudioFilters","FiltersChain","version"]}